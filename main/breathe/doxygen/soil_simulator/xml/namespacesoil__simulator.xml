<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="namespacesoil__simulator" kind="namespace" language="C++">
    <compoundname>soil_simulator</compoundname>
    <innerclass refid="classsoil__simulator_1_1_soil_dynamics" prot="public">soil_simulator::SoilDynamics</innerclass>
    <innerclass refid="classsoil__simulator_1_1_grid" prot="public">soil_simulator::Grid</innerclass>
    <innerclass refid="classsoil__simulator_1_1_bucket" prot="public">soil_simulator::Bucket</innerclass>
    <innerclass refid="classsoil__simulator_1_1_sim_param" prot="public">soil_simulator::SimParam</innerclass>
    <innerclass refid="classsoil__simulator_1_1_sim_out" prot="public">soil_simulator::SimOut</innerclass>
      <sectiondef kind="var">
      <memberdef kind="variable" id="soil__dynamics_8hpp_1abb83f81ddb27ef2a1d88a7993c3f4634" prot="public" static="no" mutable="no">
        <type>std::mt19937</type>
        <definition>std::mt19937 soil_simulator::rng</definition>
        <argsstring></argsstring>
        <name>rng</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/soil_dynamics.hpp" line="15" column="21" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/intersecting_cells.hpp" bodystart="15" bodyend="-1" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/soil_dynamics.hpp" declline="15" declcolumn="21"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="bucket__pos_8hpp_1a302e88f20b14dbf062cac9fb0913d511" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::CalcBucketPos</definition>
        <argsstring>(SimOut *sim_out, std::vector&lt; float &gt; pos, std::vector&lt; float &gt; ori, Grid grid, Bucket *bucket, SimParam sim_param, float tol)</argsstring>
        <name>CalcBucketPos</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>pos</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>ori</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_bucket" kindref="compound">Bucket</ref> *</type>
          <declname>bucket</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_param" kindref="compound">SimParam</ref></type>
          <declname>sim_param</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function determines all the cells where the bucket is located. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of the bucket origin. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ori</parametername>
</parameternamelist>
<parameterdescription>
<para>Orientation of the bucket. [Quaternion] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bucket</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the bucket object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sim_param</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The bucket position is calculated based on its reference pose stored in the <computeroutput><ref refid="classsoil__simulator_1_1_bucket" kindref="compound">Bucket</ref></computeroutput> class, as well as the provided position (<computeroutput>pos</computeroutput>) and orientation (<computeroutput>ori</computeroutput>). <computeroutput>pos</computeroutput> and <computeroutput>ori</computeroutput> are used to apply the appropriate translation and rotation to the bucket relative to its reference pose. The center of rotation is assumed to be the bucket origin. The orientation is provided using the quaternion definition. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.hpp" line="23" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.cpp" bodystart="22" bodyend="142" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.hpp" declline="23" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="bucket__pos_8hpp_1ae5c6e2a9518feb3017b99269d2f1bc34" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::vector&lt; int &gt; &gt;</type>
        <definition>std::vector&lt; std::vector&lt; int &gt; &gt; soil_simulator::CalcRectanglePos</definition>
        <argsstring>(std::vector&lt; float &gt; a, std::vector&lt; float &gt; b, std::vector&lt; float &gt; c, std::vector&lt; float &gt; d, float delta, Grid grid, float tol)</argsstring>
        <name>CalcRectanglePos</name>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>c</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>d</declname>
        </param>
        <param>
          <type>float</type>
          <declname>delta</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function determines the cells where a rectangle surface is located. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of one vertex of the rectangle. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of one vertex of the rectangle. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of one vertex of the rectangle. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>d</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of one vertex of the rectangle. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>delta</parametername>
</parameternamelist>
<parameterdescription>
<para>Spatial increment used to decompose the edges of the rectangle. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Collection of cells indices where the rectangle is located. Result is not sorted and duplicates may be present.</para>
</simplesect>
The rectangle is defined by providing the Cartesian coordinates of its four vertices in the proper order.</para>
<para>To optimize performance, the function iterates over a portion of the horizontal grid where the rectangle is located. For each cell, the function calculates the height of the plane formed by the rectangle at the top right corner of the cell. If the cell is within the rectangle area, the calcualted height is added to the results for the four neighboring cells.</para>
<para>This method works because when a plane intersects with a rectangular cell, the minimum and maximum height of the plane within the cell occurs at one of the cell corners. By iterating through all the cells, the function ensures that all the corners of each cell are investigated.</para>
<para>However, this approach does not work when the rectangle is perpendicular to the XY plane. To handle this case, the function uses the <computeroutput>CalcLinePos</computeroutput> function to include the cells that lie on the four edges of the rectangle.</para>
<para>Note:<itemizedlist>
<listitem><para>The iteration is performed over the top right corner of each cell, but any other corner could have been chosen without affecting the results.</para>
</listitem><listitem><para>Not all cells are provided, since, at a given XY position, only the cells with the minimum and maximum height are important.</para>
</listitem><listitem><para>When the rectangle follows a cell border, the exact location of the rectangle becomes ambiguous. It is assumed that the caller resolves this ambiguity. </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.hpp" line="41" column="13" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.cpp" bodystart="170" bodyend="277" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.hpp" declline="41" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="bucket__pos_8hpp_1a548c40b2efad17e1de1cefd5213b180d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; std::vector&lt; std::vector&lt; float &gt; &gt;, std::vector&lt; std::vector&lt; float &gt; &gt;, std::vector&lt; std::vector&lt; bool &gt; &gt;, int &gt;</type>
        <definition>std::tuple&lt; std::vector&lt; std::vector&lt; float &gt; &gt;, std::vector&lt; std::vector&lt; float &gt; &gt;, std::vector&lt; std::vector&lt; bool &gt; &gt;, int &gt; soil_simulator::DecomposeVectorRectangle</definition>
        <argsstring>(std::vector&lt; float &gt; ab_ind, std::vector&lt; float &gt; ad_ind, std::vector&lt; float &gt; a_ind, int area_min_x, int area_min_y, int area_length_x, int area_length_y, float tol)</argsstring>
        <name>DecomposeVectorRectangle</name>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>ab_ind</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>ad_ind</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>a_ind</declname>
        </param>
        <param>
          <type>int</type>
          <declname>area_min_x</declname>
        </param>
        <param>
          <type>int</type>
          <declname>area_min_y</declname>
        </param>
        <param>
          <type>int</type>
          <declname>area_length_x</declname>
        </param>
        <param>
          <type>int</type>
          <declname>area_length_y</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function performs a vector decomposition on a portion of the horizontal plane where a rectangle ABCD is located. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ab_ind</parametername>
</parameternamelist>
<parameterdescription>
<para>Indices representing the edge AB of the rectangle. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ad_ind</parametername>
</parameternamelist>
<parameterdescription>
<para>Indices representing the edge AD of the rectangle. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_ind</parametername>
</parameternamelist>
<parameterdescription>
<para>Indices of the vertex A from which the edges AB and AD start. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>area_min_x</parametername>
</parameternamelist>
<parameterdescription>
<para>Minimum index in the X direction of the specified area. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>area_min_y</parametername>
</parameternamelist>
<parameterdescription>
<para>Minimum index in the Y direction of the specified area. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>area_length_x</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of grid elements in the X direction of the specified area. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>area_length_y</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of grid elements in the Y direction of the specified area. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A tuple composed of a vector of vector giving the vector decomposition in terms of the AB component, a vector of vector giving the vector decomposition in terms of the AD component, a vector of vector indicating whether the cell is inside the rectangle area, and the number of cells inside the rectangle area.</para>
</simplesect>
The position of the rectangle is defined by its edges AB and AD, while the specified area extends over [<computeroutput>area_min_x</computeroutput>, <computeroutput>area_min_x + area_length_x</computeroutput>] on the X direction and [<computeroutput>area_min_y</computeroutput>, <computeroutput>area_min_y + area_length_y</computeroutput>] on the Y direction.</para>
<para>For each cell in the specified area, the function decomposes it into the basis formed by the vectors AB and AD. Let O be the name of a cell, it can then be decomposed as</para>
<para><programlisting><codeline><highlight class="normal">AO<sp/>=<sp/>c_ab<sp/>*<sp/>AB<sp/>+<sp/>c_ad<sp/>*<sp/>AD.</highlight></codeline>
</programlisting></para>
<para>This decomposition leads to a system of 2 equations with 2 unknowns (c_ab and c_ad)</para>
<para><programlisting><codeline><highlight class="normal">AO[1]<sp/>=<sp/>c_ab<sp/>*<sp/>AB[1]<sp/>+<sp/>c_ad<sp/>*<sp/>AD[1]<sp/>{1},</highlight></codeline>
<codeline><highlight class="normal">AO[2]<sp/>=<sp/>c_ab<sp/>*<sp/>AB[2]<sp/>+<sp/>c_ad<sp/>*<sp/>AD[2]<sp/>{2}.</highlight></codeline>
</programlisting></para>
<para>One may note that AB[1] * {2} - AB[2] * {1} implies that</para>
<para><programlisting><codeline><highlight class="normal">AB[1]<sp/>*<sp/>AO[2]<sp/>-<sp/>AB[2]<sp/>*<sp/>AO[1]<sp/>=<sp/>c_ad<sp/>*<sp/>AD[2]<sp/>*<sp/>AB[1]<sp/>-<sp/>c_ad<sp/>*<sp/>AD[1]<sp/>*<sp/>AB[2]</highlight></codeline>
</programlisting></para>
<para>that can be further rewritten as</para>
<para><programlisting><codeline><highlight class="normal">c_ad<sp/>=<sp/>(AB[1]<sp/>*<sp/>AO[2]<sp/>-<sp/>AB[2]<sp/>*<sp/>AO[1])<sp/>/<sp/>(AD[2]<sp/>*<sp/>AB[1]<sp/>-<sp/>AD[1]<sp/>*<sp/>AB[2]).</highlight></codeline>
</programlisting></para>
<para>Similarly, AD[1] * {2} - AD[2] * {1} implies that</para>
<para><programlisting><codeline><highlight class="normal">c_ab<sp/>=<sp/>-(AD[1]<sp/>*<sp/>AO[2]<sp/>-<sp/>AD[2]<sp/>*<sp/>AO[1])<sp/>/<sp/>(AD[2]<sp/>*<sp/>AB[1]<sp/>-<sp/>AD[1]<sp/>*<sp/>AB[2]).</highlight></codeline>
</programlisting></para>
<para>This decomposition allows us to determine whether the cell O is inside the rectangle area, since this requires c_ab and c_ad to be between 0 and 1.</para>
<para>Note: By convention, the decomposition is done at the top right corner of each cell. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.hpp" line="67" column="1" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.cpp" bodystart="327" bodyend="375" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.hpp" declline="67" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="bucket__pos_8hpp_1ac834b269e50e9b93faf48729d3322247" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::vector&lt; int &gt; &gt;</type>
        <definition>std::vector&lt; std::vector&lt; int &gt; &gt; soil_simulator::CalcTrianglePos</definition>
        <argsstring>(std::vector&lt; float &gt; a, std::vector&lt; float &gt; b, std::vector&lt; float &gt; c, float delta, Grid grid, float tol)</argsstring>
        <name>CalcTrianglePos</name>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>c</declname>
        </param>
        <param>
          <type>float</type>
          <declname>delta</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function determines the cells where a triangle surface is located. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of one vertex of the triangle. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of one vertex of the triangle. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of one vertex of the triangle. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>delta</parametername>
</parameternamelist>
<parameterdescription>
<para>Spatial increment used to decompose the edges of the triangle. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Collection of cells indices where the triangle is located. Result is not sorted and duplicates may be present.</para>
</simplesect>
The triangle is defined by providing the Cartesian coordinates of its three vertices in the proper order.</para>
<para>To optimize performance, the function iterates over a portion of the horizontal grid where the triangle is located. For each cell, the function calculates the height of the plane formed by the triangle at the top right corner of the cell. If the cell is within the triangle area, the calcualted height is added to the results for the four neighboring cells.</para>
<para>This method works because when a plane intersects with a rectangular cell, the minimum and maximum height of the plane within the cell occurs at one of the cell corners. By iterating through all the cells, the function ensures that all the corners of each cell are investigated.</para>
<para>However, this approach does not work when the triangle is perpendicular to the XY plane. To handle this case, the function uses the <computeroutput>CalcLinePos</computeroutput> function to include the cells that lie on the three edges of the triangle.</para>
<para>Note:<itemizedlist>
<listitem><para>The iteration is performed over the top right corner of each cell, but any other corner could have been chosen without affecting the results.</para>
</listitem><listitem><para>Not all cells are provided, since, at a given XY position, only the cells with the minimum and maximum height are important.</para>
</listitem><listitem><para>When the triangle follows a cell border, the exact location of the triangle becomes ambiguous. It is assumed that the caller resolves this ambiguity. </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.hpp" line="85" column="13" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.cpp" bodystart="403" bodyend="504" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.hpp" declline="85" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="bucket__pos_8hpp_1a324a3b394c8ea1a119572a05fddf37b8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; std::vector&lt; std::vector&lt; float &gt; &gt;, std::vector&lt; std::vector&lt; float &gt; &gt;, std::vector&lt; std::vector&lt; bool &gt; &gt;, int &gt;</type>
        <definition>std::tuple&lt; std::vector&lt; std::vector&lt; float &gt; &gt;, std::vector&lt; std::vector&lt; float &gt; &gt;, std::vector&lt; std::vector&lt; bool &gt; &gt;, int &gt; soil_simulator::DecomposeVectorTriangle</definition>
        <argsstring>(std::vector&lt; float &gt; ab_ind, std::vector&lt; float &gt; ac_ind, std::vector&lt; float &gt; a_ind, int area_min_x, int area_min_y, int area_length_x, int area_length_y, float tol)</argsstring>
        <name>DecomposeVectorTriangle</name>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>ab_ind</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>ac_ind</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>a_ind</declname>
        </param>
        <param>
          <type>int</type>
          <declname>area_min_x</declname>
        </param>
        <param>
          <type>int</type>
          <declname>area_min_y</declname>
        </param>
        <param>
          <type>int</type>
          <declname>area_length_x</declname>
        </param>
        <param>
          <type>int</type>
          <declname>area_length_y</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function performs a vector decomposition on a portion of the horizontal plane where a tritangle ABC is located. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ab_ind</parametername>
</parameternamelist>
<parameterdescription>
<para>Indices representing the edge AB of the triangle. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ac_ind</parametername>
</parameternamelist>
<parameterdescription>
<para>Indices representing the edge AC of the triangle. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_ind</parametername>
</parameternamelist>
<parameterdescription>
<para>Indices of the vertex A from which the edges AB and AC start. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>area_min_x</parametername>
</parameternamelist>
<parameterdescription>
<para>Minimum index in the X direction of the specified area. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>area_min_y</parametername>
</parameternamelist>
<parameterdescription>
<para>Minimum index in the Y direction of the specified area. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>area_length_x</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of grid elements in the X direction of the specified area. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>area_length_y</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of grid elements in the Y direction of the specified area. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A tuple composed of a vector of vector giving the vector decomposition in terms of the AB component, a vector of vector giving the vector decomposition in terms of the AC component, a vector of vector indicating whether the cell is inside the triangle area, and the number of cells inside the triangle area.</para>
</simplesect>
The position of the triangle is defined by its edges AB and AC, while the specified area extends over [<computeroutput>area_min_x</computeroutput>, <computeroutput>area_min_x + area_length_x</computeroutput>] on the X direction and [<computeroutput>area_min_y</computeroutput>, <computeroutput>area_min_y + area_length_y</computeroutput>] on the Y direction.</para>
<para>For each cell in the specified area, the function decomposes it into the basis formed by the vectors AB and AC. Let O be the name of a cell, it can then be decomposed as</para>
<para><programlisting><codeline><highlight class="normal">AO<sp/>=<sp/>c_ab<sp/>*<sp/>AB<sp/>+<sp/>c_ac<sp/>*<sp/>AC.</highlight></codeline>
</programlisting></para>
<para>This decomposition leads to a system of 2 equations with 2 unknowns (c_ab and c_ac)</para>
<para><programlisting><codeline><highlight class="normal">AO[1]<sp/>=<sp/>c_ab<sp/>*<sp/>AB[1]<sp/>+<sp/>c_ac<sp/>*<sp/>AC[1]<sp/>{1},</highlight></codeline>
<codeline><highlight class="normal">AO[2]<sp/>=<sp/>c_ab<sp/>*<sp/>AB[2]<sp/>+<sp/>c_ac<sp/>*<sp/>AC[2]<sp/>{2}.</highlight></codeline>
</programlisting></para>
<para>One may note that AB[1] * {2} - AB[2] * {1} implies that</para>
<para><programlisting><codeline><highlight class="normal">AB[1]<sp/>*<sp/>AO[2]<sp/>-<sp/>AB[2]<sp/>*<sp/>AO[1]<sp/>=<sp/>c_ac<sp/>*<sp/>AC[2]<sp/>*<sp/>AB[1]<sp/>-<sp/>c_ac<sp/>*<sp/>AC[1]<sp/>*<sp/>AB[2]</highlight></codeline>
</programlisting></para>
<para>that can be further rewritten as</para>
<para><programlisting><codeline><highlight class="normal">c_ac<sp/>=<sp/>(AB[1]<sp/>*<sp/>AO[2]<sp/>-<sp/>AB[2]<sp/>*<sp/>AO[1])<sp/>/<sp/>(AC[2]<sp/>*<sp/>AB[1]<sp/>-<sp/>AC[1]<sp/>*<sp/>AB[2]).</highlight></codeline>
</programlisting></para>
<para>Similarly, AC[1] * {2} - AC[2] * {1} implies that</para>
<para><programlisting><codeline><highlight class="normal">c_ab<sp/>=<sp/>-(AC[1]<sp/>*<sp/>AO[2]<sp/>-<sp/>AC[2]<sp/>*<sp/>AO[1])<sp/>/<sp/>(AC[2]<sp/>*<sp/>AB[1]<sp/>-<sp/>AC[1]<sp/>*<sp/>AB[2]).</highlight></codeline>
</programlisting></para>
<para>This decomposition allows us to determine whether the cell O is inside the triangle area, since this requires c_ab and c_ac to be between 0 and 1, and the sum of c_ab and c_ac to be lower than 1.</para>
<para>Note: By convention, the decomposition is done at the top right corner of each cell. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.hpp" line="111" column="1" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.cpp" bodystart="555" bodyend="603" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.hpp" declline="111" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="bucket__pos_8hpp_1a7645d69569b958a1323bec5204d24e64" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::vector&lt; int &gt; &gt;</type>
        <definition>std::vector&lt; std::vector&lt; int &gt; &gt; soil_simulator::CalcLinePos</definition>
        <argsstring>(std::vector&lt; float &gt; a, std::vector&lt; float &gt; b, float delta, Grid grid)</argsstring>
        <name>CalcLinePos</name>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>float</type>
          <declname>delta</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <briefdescription>
<para>This function determines all the cells that lie on a straight line between two Cartesian coordinates. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of the first extremity of the line. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of the second extremity of the line. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>delta</parametername>
</parameternamelist>
<parameterdescription>
<para>Spatial increment used to decompose the line. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Collection of cells indices where the line is located. Result is not sorted and duplicates should be expected.</para>
</simplesect>
For the sake of accuracy, the line is divided into smaller segments using a spatial increment <computeroutput>delta</computeroutput>.</para>
<para>The coordinates of each sub-point (ab_i) along the line can then be calculated as</para>
<para><programlisting><codeline><highlight class="normal">ab_i<sp/>=<sp/>a<sp/>+<sp/>ab<sp/>*<sp/>i<sp/>*<sp/>delta<sp/>/<sp/>norm(ab)</highlight></codeline>
</programlisting></para>
<para>where i is the increment number and ab = b - a. The Cartesian coordinates can then be converted into indices</para>
<para><programlisting><codeline><highlight class="normal">ab_i_ind<sp/>=<sp/>ab_i<sp/>/<sp/>cell_size<sp/>+<sp/>grid_half_length<sp/>+<sp/>1</highlight></codeline>
</programlisting></para>
<para>Finally, the floating-point values are rounded to obtain the cell indices in the X, Y, Z directions. As the center of each cell is considered to be on the center of the top surface, <computeroutput>round</computeroutput> should be used for getting the cell indices in the X and Y direction, while <computeroutput>ceil</computeroutput> should be used for the Z direction.</para>
<para>Note: When the line follows a cell border, the exact location of the line becomes ambiguous. It is assumed that the caller resolves this ambiguity. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.hpp" line="126" column="13" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.cpp" bodystart="631" bodyend="668" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.hpp" declline="126" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="bucket__pos_8hpp_1a04a0807350c0592bf1b49aa84dc672ef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::UpdateBody</definition>
        <argsstring>(std::vector&lt; std::vector&lt; int &gt;&gt; area_pos, SimOut *sim_out, Grid grid, float tol)</argsstring>
        <name>UpdateBody</name>
        <param>
          <type>std::vector&lt; std::vector&lt; int &gt;&gt;</type>
          <declname>area_pos</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function updates the bucket position in <computeroutput>body</computeroutput> following the cells composing <computeroutput>area_pos</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>area_pos</parametername>
</parameternamelist>
<parameterdescription>
<para>A collection of cell indices specifying where a bucket wall is located. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
For each XY position, the first cell found in <computeroutput>area_pos</computeroutput> corresponds to the minimum height of the bucket, while the last one provides the maximum height. As a result, this function must be called separately for each bucket wall and <computeroutput>area_pos</computeroutput> must be sorted. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.hpp" line="137" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.cpp" bodystart="674" bodyend="706" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.hpp" declline="137" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="bucket__pos_8hpp_1a3ea4ec8bd8dc0b85dbdec40a39442bcc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::IncludeNewBodyPos</definition>
        <argsstring>(SimOut *sim_out, int ii, int jj, float min_h, float max_h, float tol)</argsstring>
        <name>IncludeNewBodyPos</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ii</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jj</declname>
        </param>
        <param>
          <type>float</type>
          <declname>min_h</declname>
        </param>
        <param>
          <type>float</type>
          <declname>max_h</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function updates the bucket position in <computeroutput>body</computeroutput> at the coordinates (<computeroutput>ii</computeroutput>, <computeroutput>jj</computeroutput>). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ii</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered position in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jj</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered position in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>min_h</parametername>
</parameternamelist>
<parameterdescription>
<para>Minimum height of the bucket. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_h</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum height of the bucket. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The minimum and maximum heights of the bucket at that position are given by <computeroutput>min_h</computeroutput> and <computeroutput>max_h</computeroutput>, respectively. If the given position overlaps with an existing position, then the existing position is updated as the union of the two positions. Otherwise, a new position is added to <computeroutput>body_</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.hpp" line="149" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.cpp" bodystart="713" bodyend="780" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/bucket_pos.hpp" declline="149" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="body__soil_8hpp_1ab50aafffc9911dee1104a68341d7d4a4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::UpdateBodySoil</definition>
        <argsstring>(SimOut *sim_out, std::vector&lt; float &gt; pos, std::vector&lt; float &gt; ori, Grid grid, Bucket *bucket, float tol)</argsstring>
        <name>UpdateBodySoil</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>pos</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>ori</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_bucket" kindref="compound">Bucket</ref> *</type>
          <declname>bucket</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function moves the soil resting on the bucket following its movement. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of the bucket origin. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ori</parametername>
</parameternamelist>
<parameterdescription>
<para>Orientation of the bucket. [Quaternion] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bucket</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the bucket object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
In this function, the movement applied to the base of the soil column is calculated and the soil is moved to this new location. It is however difficult to track accurately each bucket wall. This is currently done by looking at the height difference between the previous and new soil locations, if this height difference is lower than <computeroutput>cell_size_xy_</computeroutput>, it is assumed to be the same bucket wall. Some errors may however be present and further testing is required. If no bucket wall is present, the soil is moved down to the terrain.</para>
<para>The new positions of the soil resting on the bucket are collected into <computeroutput>sim_out.body_soil_pos_</computeroutput> and duplicates are removed. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/body_soil.hpp" line="23" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/body_soil.cpp" bodystart="26" bodyend="145" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/body_soil.hpp" declline="23" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="intersecting__cells_8hpp_1a9d38a4b3998507e89943b2aa74d54476" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::MoveIntersectingCells</definition>
        <argsstring>(SimOut *sim_out, float tol)</argsstring>
        <name>MoveIntersectingCells</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function moves all soil cells in <computeroutput>terrain_</computeroutput> and in <computeroutput>body_soil_</computeroutput> that intersect with the bucket or with another soil cell. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Note that <computeroutput>MoveIntersectingBodySoil</computeroutput> must be called before <computeroutput>MoveIntersectingBody</computeroutput>, otherwise some intersecting soil cells may remain. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/intersecting_cells.hpp" line="22" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/intersecting_cells.cpp" bodystart="17" bodyend="24" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/intersecting_cells.hpp" declline="22" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="intersecting__cells_8hpp_1a81b23c9cf33af5de4da526de32fc3e4b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::MoveIntersectingBodySoil</definition>
        <argsstring>(SimOut *sim_out, float tol)</argsstring>
        <name>MoveIntersectingBodySoil</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function moves the soil cells resting on the bucket that intersect with another bucket layer. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function checks the eight lateral directions surrounding the intersecting soil column and moves the soil to available spaces.</para>
<para>The algorithm follows an incremental approach, checking directions farther from the intersecting soil column until it reaches a bucket wall blocking the movement or until all the soil has been moved. If the movement is blocked by a bucket wall, the algorithm explores another direction.</para>
<para>In cases where the soil should be moved to the terrain, all soil is moved regardless of the available space. If this movement induces intersecting soil cells, it will be resolved by the <computeroutput>MoveIntersectingBody!</computeroutput> function.</para>
<para>In rare situations where there is insufficient space to accommodate all the intersecting soil, the algorithm currently handles it by allowing the excess soil to simply disappear. This compromise seems to be reasonable as long as the amount of soil disappearing remains negligible.</para>
<para>Note that the order in which the directions are checked is randomized in order to avoid asymmetrical results. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/intersecting_cells.hpp" line="29" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/intersecting_cells.cpp" bodystart="45" bodyend="136" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/intersecting_cells.hpp" declline="29" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="intersecting__cells_8hpp_1af3ee72c596b5a2a237b4b95f7ffe51a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::MoveIntersectingBody</definition>
        <argsstring>(SimOut *sim_out, float tol)</argsstring>
        <name>MoveIntersectingBody</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function moves the soil cells in the <computeroutput>terrain_</computeroutput> that intersect with a bucket. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function checks the eight lateral directions surrounding the intersecting soil column and moves the soil to available spaces. If there is insufficient space for all the soil, it incrementally checks the eight directions farther from the intersecting soil column until all the soil has been moved. The process can be illustrated as follows <verbatim>            ↖   ↑   ↗
              ↖ ↑ ↗
            ← ← O → →
              ↙ ↓ ↘
            ↙   ↓   ↘
</verbatim> Note that the order in which the directions are checked is randomized in order to avoid asymmetrical results. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/intersecting_cells.hpp" line="36" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/intersecting_cells.cpp" bodystart="152" bodyend="251" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/intersecting_cells.hpp" declline="36" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="intersecting__cells_8hpp_1a8782f9bf7be372b263e6d4c045a2c802" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; int, int, int, float, bool &gt;</type>
        <definition>std::tuple&lt; int, int, int, float, bool &gt; soil_simulator::MoveBodySoil</definition>
        <argsstring>(SimOut *sim_out, int ind_p, int ii_p, int jj_p, float max_h, int ii_n, int jj_n, float h_soil, bool wall_presence, float tol)</argsstring>
        <name>MoveBodySoil</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ind_p</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ii_p</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jj_p</declname>
        </param>
        <param>
          <type>float</type>
          <declname>max_h</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ii_n</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jj_n</declname>
        </param>
        <param>
          <type>float</type>
          <declname>h_soil</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>wall_presence</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function tries to move the soil cells resting on the bucket layer <computeroutput>ind_p</computeroutput> at the location (<computeroutput>ii_p</computeroutput>, <computeroutput>jj_p</computeroutput>) to a new location at (<computeroutput>ii_n</computeroutput>, <computeroutput>jj_n</computeroutput>). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ind_p</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the previous considered bucket layer. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ii_p</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the previous considered position in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jj_p</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the previous considered position in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_h</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum height authorized for the movement. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ii_n</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the new considered position in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jj_n</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the new considered position in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>h_soil</parametername>
</parameternamelist>
<parameterdescription>
<para>Height of the soil column left to be moved. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>wall_presence</parametername>
</parameternamelist>
<parameterdescription>
<para>Indicates whether a wall is blocking the movement. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A tuple composed of the index of the new considered bucket layer, the index of the new considered position in the X direction, the index of the new considered position in the Y direction, the height of the soil column left to be moved, and a boolean indicating whether a bucket wall is blocking the movement.</para>
</simplesect>
This function can be separated into three main scenarios:<itemizedlist>
<listitem><para>If all the soil can be moved to the new location (either on the terrain or on the bucket), the soil is moved and the value of <computeroutput>h_soil</computeroutput> is set to zero.</para>
</listitem><listitem><para>If a bucket wall is blocking the movement, the <computeroutput>wall_presence</computeroutput> parameter is set to <computeroutput>true</computeroutput>.</para>
</listitem><listitem><para>If there is insufficient space to move all the soil but no bucket wall is blocking the movement, the function updates the values for the new location and adjusts <computeroutput>h_soil</computeroutput> accordingly.</para>
</listitem></itemizedlist>
</para>
<para>This function is designed to be used iteratively by the function <computeroutput>MoveIntersectingBodySoil</computeroutput> until all intersecting soil cells are moved.</para>
<para>Note that, by convention, the soil can be moved from the bucket to the terrain even if the bucket is underground. Moreover, in cases where the soil should be moved to the terrain, all soil is moved regardless of the available space. If this movement induces intersecting soil cells, it will be resolved by <computeroutput>MoveIntersectingBody</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/intersecting_cells.hpp" line="58" column="12" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/intersecting_cells.cpp" bodystart="271" bodyend="461" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/intersecting_cells.hpp" declline="58" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="intersecting__cells_8hpp_1a440356f5f2e5b422bf5ba55bb8b74d47" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::vector&lt; int &gt; &gt;</type>
        <definition>std::vector&lt; std::vector&lt; int &gt; &gt; soil_simulator::LocateIntersectingCells</definition>
        <argsstring>(SimOut *sim_out, float tol)</argsstring>
        <name>LocateIntersectingCells</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function identifies all the soil cells in the <computeroutput>terrain_</computeroutput> that intersect with the bucket. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/intersecting_cells.hpp" line="67" column="13" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/intersecting_cells.cpp" bodystart="463" bodyend="493" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/intersecting_cells.hpp" declline="67" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="relax_8hpp_1adba6d77a9de31f9f32f1f94be197b745" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::RelaxTerrain</definition>
        <argsstring>(SimOut *sim_out, Grid grid, SimParam sim_param, float tol)</argsstring>
        <name>RelaxTerrain</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_param" kindref="compound">SimParam</ref></type>
          <declname>sim_param</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function moves the soil in <computeroutput>terrain_</computeroutput> towards a state closer to equilibrium. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sim_param</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The soil stability is determined by the <computeroutput>repose_angle_</computeroutput>. If the slope formed by two neighboring soil columns exceeds the <computeroutput>repose_angle_</computeroutput>, it is considered unstable, and the soil from the higher column should avalanche to the neighboring column to reach an equilibrium state.</para>
<para>By convention, this function only checks the stability of the soil in the four adjacent cells: ↑ ← O → ↓</para>
<para>The diagonal directions are not checked for simplicity and performance reasons.</para>
<para>This function only moves the soil when the following conditions are met:</para>
<para>(1) The soil column in the neighboring cell is low enough. (2) Either: (a) The bucket is not on the soil, meaning there is space between the <computeroutput>terrain_</computeroutput> and the bucket, or there is no bucket. (b) The bucket is on the <computeroutput>terrain_</computeroutput>, but the combination of the bucket and bucket soil is not high enough to prevent soil avalanche.</para>
<para>In case (2a), the soil will avalanche on the <computeroutput>terrain_</computeroutput>, while in case (2b), the soil will avalanche on the bucket. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/relax.hpp" line="23" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/relax.cpp" bodystart="41" bodyend="136" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/relax.hpp" declline="23" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="relax_8hpp_1a664e090b8814033e581d22394278c461" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::RelaxBodySoil</definition>
        <argsstring>(SimOut *sim_out, Grid grid, SimParam sim_param, float tol)</argsstring>
        <name>RelaxBodySoil</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_param" kindref="compound">SimParam</ref></type>
          <declname>sim_param</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function moves the soil in <computeroutput>body_soil_</computeroutput> towards a state closer to equilibrium. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sim_param</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The soil stability is determined by the <computeroutput>repose_angle_</computeroutput>. If the slope formed by two neighboring soil columns exceeds the <computeroutput>repose_angle_</computeroutput>, it is considered unstable, and the soil from the higher column should avalanche to the neighboring column to reach an equilibrium state.</para>
<para>By convention, this function only checks the stability of the soil in the four adjacent cells: ↑ ← O → ↓</para>
<para>The diagonal directions are not checked for simplicity and performance reasons.</para>
<para>This function only moves the soil when the following conditions are met:</para>
<para>(1) The soil column in the neighboring cell is low enough. (2) There is space on the top of the neighboring soil column. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/relax.hpp" line="32" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/relax.cpp" bodystart="156" bodyend="236" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/relax.hpp" declline="32" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="relax_8hpp_1a0a8c6ad78abd12190ab2b54483ce7bf6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::vector&lt; int &gt; &gt;</type>
        <definition>std::vector&lt; std::vector&lt; int &gt; &gt; soil_simulator::LocateUnstableTerrainCell</definition>
        <argsstring>(SimOut *sim_out, float dh_max, float tol)</argsstring>
        <name>LocateUnstableTerrainCell</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>float</type>
          <declname>dh_max</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function locates all the cells in <computeroutput>terrain_</computeroutput> that have a height difference larger than <computeroutput>dh_max</computeroutput> with at least one neighboring cell. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dh_max</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum height difference allowed between two neighboring cells. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Collection of cells indices that are possibly unstable.</para>
</simplesect>
It is important to note that the cells selected by this function are not necessarily unstable, as a bucket or the soil resting on it could be supporting the soil column. This is only a first-order selection of cells potentially unstable. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/relax.hpp" line="43" column="13" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/relax.cpp" bodystart="242" bodyend="271" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/relax.hpp" declline="43" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="relax_8hpp_1ab7ab093b938d3cd2678a004f26fdb7e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int soil_simulator::CheckUnstableTerrainCell</definition>
        <argsstring>(SimOut *sim_out, int ii_c, int jj_c, float h_min, float tol)</argsstring>
        <name>CheckUnstableTerrainCell</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ii_c</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jj_c</declname>
        </param>
        <param>
          <type>float</type>
          <declname>h_min</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function checks the stability of a soil column in <computeroutput>terrain_</computeroutput> compared to one of its neighbor (<computeroutput>ii_c</computeroutput>, <computeroutput>jj_c</computeroutput>) </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ii_c</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the neighboring cell in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jj_c</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the neighboring cell in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>h_min</parametername>
</parameternamelist>
<parameterdescription>
<para>Minimum allowed height for a stable configuration. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Three-digit number indicating how the soil should avalanche. <computeroutput>0</computeroutput> is returned if the soil column is stable.</para>
</simplesect>
In case of instability, this function returns a three-digit number (<computeroutput>status</computeroutput>) that provides information on how the soil should avalanche. The interpretation of the three-digit number is described below.</para>
<para>The first digit indicates the potential presence of the bucket:<itemizedlist>
<listitem><para>1 when the first bucket layer is present.</para>
</listitem><listitem><para>2 when the second bucket layer is present.</para>
</listitem><listitem><para>3 when the two bucket layers are present.</para>
</listitem><listitem><para>4 when no bucket layer is present.</para>
</listitem></itemizedlist>
</para>
<para>The second digit indicates the layer at the top where the soil should avalanche:<itemizedlist>
<listitem><para>0 when it is the <computeroutput>terrain</computeroutput> (no bucket is present).</para>
</listitem><listitem><para>1 when it is the second bucket soil layer.</para>
</listitem><listitem><para>2 when it is the second bucket layer.</para>
</listitem><listitem><para>3 when it is the first bucket soil layer.</para>
</listitem><listitem><para>4 when it is the first bucket layer.</para>
</listitem></itemizedlist>
</para>
<para>The third digit indicates whether the soil should avalanche below or above the bucket:<itemizedlist>
<listitem><para>0 when there is no bucket.</para>
</listitem><listitem><para>1 when the soil should avalanche below the bucket.</para>
</listitem><listitem><para>2 when the soil should avalanche on the top of the bucket.</para>
</listitem></itemizedlist>
</para>
<para>The combination of these three digits provides a comprehensive description of how the soil should avalanche in different scenarios.</para>
<para>Note that not all combinations for <computeroutput>status</computeroutput> are possible. Some combinations, such as <computeroutput>401</computeroutput>, <computeroutput>231</computeroutput> and <computeroutput>220</computeroutput>, are impossible. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/relax.hpp" line="57" column="5" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/relax.cpp" bodystart="302" bodyend="413" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/relax.hpp" declline="57" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="relax_8hpp_1a846b24cfecc8f7c152a08debe27953c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int soil_simulator::CheckUnstableBodyCell</definition>
        <argsstring>(SimOut *sim_out, int ii, int jj, int ind, int ii_c, int jj_c, float h_min, float tol)</argsstring>
        <name>CheckUnstableBodyCell</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ii</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jj</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ind</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ii_c</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jj_c</declname>
        </param>
        <param>
          <type>float</type>
          <declname>h_min</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function checks the stability of a soil column in the soil layer <computeroutput>ind</computeroutput> of <computeroutput>body_soil_</computeroutput> at (<computeroutput>ii</computeroutput>, <computeroutput>jj</computeroutput>) compared to one of its neighbor at (<computeroutput>ii_c</computeroutput>, <computeroutput>jj_c</computeroutput>). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ii</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered cell in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jj</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered cell in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ind</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered soil layer. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ii_c</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the neighboring cell in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jj_c</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the neighboring cell in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>h_min</parametername>
</parameternamelist>
<parameterdescription>
<para>Minimum allowed height for a stable configuration. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Two-digit number indicating how the soil should avalanche. <computeroutput>0</computeroutput> is returned if the soil column is stable.</para>
</simplesect>
In case of instability, this function returns a two-digit number (<computeroutput>status</computeroutput>) that provides information on how the soil should avalanche. The interpretation of the two-digit number is described below.</para>
<para>The first digit indicates the potential presence of the bucket:<itemizedlist>
<listitem><para>1 when the first bucket layer is present.</para>
</listitem><listitem><para>2 when the second bucket layer is present.</para>
</listitem><listitem><para>3 when the two bucket layers are present.</para>
</listitem><listitem><para>4 when no bucket layer is present.</para>
</listitem></itemizedlist>
</para>
<para>The second digit indicates the layer where the soil should avalanche:<itemizedlist>
<listitem><para>0 when it is the <computeroutput>terrain</computeroutput> (no bucket is present).</para>
</listitem><listitem><para>1 when it is the second bucket soil layer.</para>
</listitem><listitem><para>2 when it is the second bucket layer.</para>
</listitem><listitem><para>3 when it is the first bucket soil layer.</para>
</listitem><listitem><para>4 when it is the first bucket layer.</para>
</listitem></itemizedlist>
</para>
<para>The combination of these two digits provides a comprehensive description of how the soil should avalanche in different scenarios.</para>
<para>Note that not all combinations for <computeroutput>status</computeroutput> are possible. Some combinations, such as <computeroutput>41</computeroutput> and <computeroutput>23</computeroutput> are impossible. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/relax.hpp" line="75" column="5" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/relax.cpp" bodystart="437" bodyend="560" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/relax.hpp" declline="75" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="relax_8hpp_1abff80b8641b27531ca4fe202ba0fa162" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::RelaxUnstableTerrainCell</definition>
        <argsstring>(SimOut *sim_out, int status, float dh_max, int ii, int jj, int ii_c, int jj_c, Grid grid, float tol)</argsstring>
        <name>RelaxUnstableTerrainCell</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>int</type>
          <declname>status</declname>
        </param>
        <param>
          <type>float</type>
          <declname>dh_max</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ii</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jj</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ii_c</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jj_c</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function moves the soil from the <computeroutput>terrain_</computeroutput> at (<computeroutput>ii</computeroutput>, <computeroutput>jj</computeroutput>) to the soil column in (<computeroutput>ii_c</computeroutput>, <computeroutput>jj_c</computeroutput>). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>status</parametername>
</parameternamelist>
<parameterdescription>
<para>Three-digit number indicating how the soil should avalanche. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dh_max</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum height difference allowed between two neighboring cells. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ii</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered cell in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jj</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered cell in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ii_c</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the neighboring cell in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jj_c</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the neighboring cell in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The precise movement applied to the soil cell depends on the <computeroutput>status</computeroutput> number provided by the <computeroutput>CheckUnstableTerrainCell</computeroutput> function.</para>
<para>The soil is moved such that the slope formed by the two neighboring soil columns is equal to the <computeroutput>repose_angle_</computeroutput>. When the bucket is preventing this configuration, the soil avalanche below the bucket to fill the space under it.</para>
<para>Note that it is assumed that the given <computeroutput>status</computeroutput> is accurate, so no extra checks are present. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/relax.hpp" line="92" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/relax.cpp" bodystart="572" bodyend="686" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/relax.hpp" declline="92" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="relax_8hpp_1ab302e765b73adc70fb91f5ae814a577d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::RelaxUnstableBodyCell</definition>
        <argsstring>(SimOut *sim_out, int status, std::vector&lt; std::vector&lt; int &gt;&gt; *body_soil_pos, float dh_max, int ii, int jj, int ind, int ii_c, int jj_c, Grid grid, float tol)</argsstring>
        <name>RelaxUnstableBodyCell</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>int</type>
          <declname>status</declname>
        </param>
        <param>
          <type>std::vector&lt; std::vector&lt; int &gt;&gt; *</type>
          <declname>body_soil_pos</declname>
        </param>
        <param>
          <type>float</type>
          <declname>dh_max</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ii</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jj</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ind</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ii_c</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jj_c</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function moves the soil from the soil layer <computeroutput>ind</computeroutput> of <computeroutput>body_soil_</computeroutput> at (<computeroutput>ii</computeroutput>, <computeroutput>jj</computeroutput>) to the soil column in (<computeroutput>ii_c</computeroutput>, <computeroutput>jj_c</computeroutput>). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>status</parametername>
</parameternamelist>
<parameterdescription>
<para>Two-digit number indicating how the soil should avalanche. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>body_soil_pos</parametername>
</parameternamelist>
<parameterdescription>
<para>Queue to append new body_soil_pos. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dh_max</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum height difference allowed between two neighboring cells. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ii</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered cell in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jj</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered cell in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ind</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered soil layer. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ii_c</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the neighboring cell in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jj_c</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the neighboring cell in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The precise movement applied to the soil cell depends on the <computeroutput>status</computeroutput> number provided by the <computeroutput>CheckUnstableBodyCell</computeroutput> function.</para>
<para>The soil is moved such that the slope formed by the two neighboring soil columns is equal to the <computeroutput>repose_angle_</computeroutput>, provided that the bucket is not preventing this configuration.</para>
<para>Note that it is assumed that the given <computeroutput>status</computeroutput> is accurate, so no extra checks are present. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/relax.hpp" line="111" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/relax.cpp" bodystart="697" bodyend="1097" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/relax.hpp" declline="111" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="utils_8hpp_1a0647bb972b73b90dffefed418fe8afc6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; float &gt;</type>
        <definition>std::vector&lt; float &gt; soil_simulator::CalcNormal</definition>
        <argsstring>(std::vector&lt; float &gt; a, std::vector&lt; float &gt; b, std::vector&lt; float &gt; c)</argsstring>
        <name>CalcNormal</name>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>This function calculates the unit normal vector of a plane formed by three points using the right-hand rule. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of the first point of the plane. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of the second point of the plane. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of the third point of the plane. [m]</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Unit normal vector of the provided plane. [m] </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.hpp" line="22" column="13" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.cpp" bodystart="16" bodyend="36" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.hpp" declline="22" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="utils_8hpp_1a1f96f36b03ea5e7fd7acf8774a346350" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; float &gt;</type>
        <definition>std::vector&lt; float &gt; soil_simulator::CalcRotationQuaternion</definition>
        <argsstring>(std::vector&lt; float &gt; ori, std::vector&lt; float &gt; pos)</argsstring>
        <name>CalcRotationQuaternion</name>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>ori</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>pos</declname>
        </param>
        <briefdescription>
<para>This function applies a rotation <computeroutput>ori</computeroutput> to the Cartesian coordinates <computeroutput>pos</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>The Quaternion convention is used for 3D rotation.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ori</parametername>
</parameternamelist>
<parameterdescription>
<para>Orientation of the bucket. [Quaternion] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of one point of the bucket in its reference pose relative to the bucket origin. [m]</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Rotated Cartesian coordinates of the input <computeroutput>pos</computeroutput> relative to the bucket origin. [m]</para>
</simplesect>
The mathematical reasoning behind this implementation can be easily found in the Wiki page of Quaternion or elsewhere. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.hpp" line="36" column="13" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.cpp" bodystart="40" bodyend="57" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.hpp" declline="36" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="utils_8hpp_1acd568e6b041aae700f5e1b915c8d90e7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; float &gt;</type>
        <definition>std::vector&lt; float &gt; soil_simulator::AngleToQuat</definition>
        <argsstring>(std::vector&lt; float &gt; ori)</argsstring>
        <name>AngleToQuat</name>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>ori</declname>
        </param>
        <briefdescription>
<para>This function converts Euler angles following the ZYX convention to a quaternion. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ori</parametername>
</parameternamelist>
<parameterdescription>
<para>Orientation of the bucket. [Euler angles, ZYX sequence]</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Orientation of the bucket. [Quaternion]</para>
</simplesect>
The mathematical reasoning behind this implementation can be easily found in the Wiki page of Quaternion or elsewhere.</para>
<para>Note that this function only works if the Euler angles follow the ZYX convention. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.hpp" line="45" column="13" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.cpp" bodystart="64" bodyend="90" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.hpp" declline="45" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="utils_8hpp_1a65d6a37c7717cf60059c53d09e684532" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; float &gt;</type>
        <definition>std::vector&lt; float &gt; soil_simulator::MultiplyQuaternion</definition>
        <argsstring>(std::vector&lt; float &gt; q1, std::vector&lt; float &gt; q2)</argsstring>
        <name>MultiplyQuaternion</name>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>q1</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>q2</declname>
        </param>
        <briefdescription>
<para>This function calculates the product of two Quaternions. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>q1</parametername>
</parameternamelist>
<parameterdescription>
<para>First quaternion. [Quaternion] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>q2</parametername>
</parameternamelist>
<parameterdescription>
<para>Second quaternion. [Quaternion]</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Product of the two inputs quaternions. [Quaternion]</para>
</simplesect>
The mathematical reasoning behind this implementation can be easily found in the Wiki page of Quaternion or elsewhere. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.hpp" line="53" column="13" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.cpp" bodystart="94" bodyend="107" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.hpp" declline="53" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="utils_8hpp_1aa73c7a46ed52e9eeb51bcd48e459e4b9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool soil_simulator::CheckVolume</definition>
        <argsstring>(SimOut *sim_out, float init_volume, Grid grid)</argsstring>
        <name>CheckVolume</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>float</type>
          <declname>init_volume</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <briefdescription>
<para>This function checks that the volume of soil is conserved. </para>
        </briefdescription>
        <detaileddescription>
<para>The initial volume of soil (<computeroutput>init_volume</computeroutput>) has to be provided.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init_volume</parametername>
</parameternamelist>
<parameterdescription>
<para>Initial volume of soil in the terrain. [m^3] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Boolean indicating whether soil is conserved or not. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.hpp" line="63" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.cpp" bodystart="110" bodyend="149" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.hpp" declline="63" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="utils_8hpp_1a79a35e16ac590fb4b828ea43c7f5b891" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool soil_simulator::CheckSoil</definition>
        <argsstring>(SimOut *sim_out, float tol)</argsstring>
        <name>CheckSoil</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function checks that all the simulation outputs follow the conventions of the simulator. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Boolean indicating whether the simulation outputs are consistent.</para>
</simplesect>
The conventions that are checked by this function include:<itemizedlist>
<listitem><para>The terrain should not overlap with the bucket.</para>
</listitem><listitem><para>The bucket should be properly defined, with its maximum height higher than its minimum height.</para>
</listitem><listitem><para>The bucket soil should be properly defined, with its maximum height higher than its minimum height.</para>
</listitem><listitem><para>The two bucket layers should not overlap or touch each other.</para>
</listitem><listitem><para>One bucket layer should not overlap with all bucket soil layer.</para>
</listitem><listitem><para>The bucket should not overlap with the corresponding bucket soil layer.</para>
</listitem><listitem><para>The bucket soil layer should be resting on the corresponding bucket layer.</para>
</listitem><listitem><para>The bucket should be present when there is bucket soil. </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.hpp" line="72" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.cpp" bodystart="162" bodyend="334" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.hpp" declline="72" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="utils_8hpp_1a3a1312acf11adcd75455909ec81fceb7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::WriteSoil</definition>
        <argsstring>(SimOut *sim_out, Grid grid)</argsstring>
        <name>WriteSoil</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <briefdescription>
<para>This function writes the terrain and the bucket soil into a csv located in the <computeroutput>results</computeroutput> directory. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>terrain</computeroutput> and <computeroutput>body_soil</computeroutput> are saved into files named <computeroutput>terrain</computeroutput> and <computeroutput>body_soil</computeroutput>, respectively, followed by the file number. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.hpp" line="79" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.cpp" bodystart="338" bodyend="406" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.hpp" declline="79" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="utils_8hpp_1a2d9951b9f38d874e35c6a4c31abf1873" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::WriteBucket</definition>
        <argsstring>(Bucket *bucket)</argsstring>
        <name>WriteBucket</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_bucket" kindref="compound">Bucket</ref> *</type>
          <declname>bucket</declname>
        </param>
        <briefdescription>
<para>This function writes the position of all bucket faces into a csv located in the <computeroutput>results</computeroutput> directory. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The bucket corners are saved into a file named <computeroutput>bucket</computeroutput> followed by the file number. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.hpp" line="85" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.cpp" bodystart="410" bodyend="509" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/utils.hpp" declline="85" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="soil__evolution_8hpp_1a3f5b0d4194a5c9e074306089e81c71ce" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::SoilEvolution</definition>
        <argsstring>(bool set_rng, bool random_trajectory, bool logging, bool check_outputs, bool write_outputs)</argsstring>
        <name>SoilEvolution</name>
        <param>
          <type>bool</type>
          <declname>set_rng</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>random_trajectory</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>logging</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>check_outputs</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>write_outputs</declname>
        </param>
        <briefdescription>
<para>This function provides an example script to run the simulator. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>set_rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Indicates whether the RNG seed is set or not. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>random_trajectory</parametername>
</parameternamelist>
<parameterdescription>
<para>Indicates whether the default trajectory or a randomized one is used. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>logging</parametername>
</parameternamelist>
<parameterdescription>
<para>Indicates whether logging information are provided. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>check_outputs</parametername>
</parameternamelist>
<parameterdescription>
<para>Indicates whether to run simulation outputs check at every step. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>write_outputs</parametername>
</parameternamelist>
<parameterdescription>
<para>Indicates whether the simulation outputs are written into files at every step.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This example script simulates a bucket performing a simple digging scoop in the XZ plane following a parabolic trajectory. There is an option to randomize the parabolic trajectory by selecting the initial position (<computeroutput>x_i</computeroutput>, <computeroutput>z_i</computeroutput>) of the bucket and the deepest point of the scoop (<computeroutput>x_min</computeroutput>, <computeroutput>z_min</computeroutput>) wihtin reasonable ranges.</para>
<para>Note that the parabolic trajectory assumes that the orientation of the bucket follows the gradient of the trajectory. While it may not be fully accurate, it provides a good approximation for testing the simulator. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/test/example/soil_evolution.hpp" line="20" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/test/example/soil_evolution.cpp" bodystart="28" bodyend="308" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/test/example/soil_evolution.hpp" declline="20" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="soil__evolution_8hpp_1a8688bd9d156d0aaa67a1f95287315165" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; std::vector&lt; std::vector&lt; float &gt; &gt;, std::vector&lt; std::vector&lt; float &gt; &gt;&gt;</type>
        <definition>std::tuple&lt; std::vector&lt;std::vector&lt;float&gt; &gt;, std::vector&lt;std::vector&lt;float&gt; &gt;&gt; soil_simulator::CalcTrajectory</definition>
        <argsstring>(float x_i, float z_i, float x_min, float z_min, int nn)</argsstring>
        <name>CalcTrajectory</name>
        <param>
          <type>float</type>
          <declname>x_i</declname>
        </param>
        <param>
          <type>float</type>
          <declname>z_i</declname>
        </param>
        <param>
          <type>float</type>
          <declname>x_min</declname>
        </param>
        <param>
          <type>float</type>
          <declname>z_min</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nn</declname>
        </param>
        <briefdescription>
<para>This function calculates a parabolic trajectory given the starting position (<computeroutput>x_i</computeroutput>, <computeroutput>z_i</computeroutput>) and the deepest position (<computeroutput>x_min</computeroutput>, <computeroutput>z_min</computeroutput>) of the trajectory. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x_i</parametername>
</parameternamelist>
<parameterdescription>
<para>X coordinate of the starting position of the trajectory. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z_i</parametername>
</parameternamelist>
<parameterdescription>
<para>Z coordinate of the starting position of the trajectory. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x_min</parametername>
</parameternamelist>
<parameterdescription>
<para>X coordinate of the deepest position of the trajectory. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z_min</parametername>
</parameternamelist>
<parameterdescription>
<para>Z coordinate of the deepest position of the trajectory. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nn</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of increments in the trajectory.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A tuple composed of a vector aggregating the position of the bucket with time in meter, and a vector aggregating the orientation of the bucket with time following the quaternion convention. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/test/example/soil_evolution.hpp" line="39" column="2" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/test/example/soil_evolution.hpp" declline="39" declcolumn="2"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/src/soil_dynamics.hpp" line="12" column="1"/>
  </compounddef>
</doxygen>
