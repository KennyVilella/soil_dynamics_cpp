<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="namespacesoil__simulator" kind="namespace" language="C++">
    <compoundname>soil_simulator</compoundname>
    <innerclass refid="classsoil__simulator_1_1_soil_dynamics" prot="public">soil_simulator::SoilDynamics</innerclass>
    <innerclass refid="structsoil__simulator_1_1body__soil" prot="public">soil_simulator::body_soil</innerclass>
    <innerclass refid="classsoil__simulator_1_1_grid" prot="public">soil_simulator::Grid</innerclass>
    <innerclass refid="classsoil__simulator_1_1_body" prot="public">soil_simulator::Body</innerclass>
    <innerclass refid="classsoil__simulator_1_1_bucket" prot="public">soil_simulator::Bucket</innerclass>
    <innerclass refid="classsoil__simulator_1_1_blade" prot="public">soil_simulator::Blade</innerclass>
    <innerclass refid="classsoil__simulator_1_1_sim_param" prot="public">soil_simulator::SimParam</innerclass>
    <innerclass refid="classsoil__simulator_1_1_sim_out" prot="public">soil_simulator::SimOut</innerclass>
      <sectiondef kind="var">
      <memberdef kind="variable" id="soil__dynamics_8hpp_1abb83f81ddb27ef2a1d88a7993c3f4634" prot="public" static="no" mutable="no">
        <type>std::mt19937</type>
        <definition>std::mt19937 soil_simulator::rng</definition>
        <argsstring></argsstring>
        <name>rng</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/soil_dynamics.hpp" line="15" column="21" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/intersecting_cells.hpp" bodystart="15" bodyend="-1" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/soil_dynamics.hpp" declline="15" declcolumn="21"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="body__pos_8hpp_1ae2c6c350f6fff2bc54d13ebe42b0c274" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::CalcBodyPos</definition>
        <argsstring>(SimOut *sim_out, std::vector&lt; float &gt; pos, std::vector&lt; float &gt; ori, Grid grid, Bucket *bucket, SimParam sim_param, float tol)</argsstring>
        <name>CalcBodyPos</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>pos</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>ori</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_bucket" kindref="compound">Bucket</ref> *</type>
          <declname>bucket</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_param" kindref="compound">SimParam</ref></type>
          <declname>sim_param</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function determines all the cells where the bucket is located. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of the bucket origin. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ori</parametername>
</parameternamelist>
<parameterdescription>
<para>Orientation of the bucket. [Quaternion] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bucket</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the bucket object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sim_param</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The bucket position is calculated based on its reference pose stored in the <computeroutput><ref refid="classsoil__simulator_1_1_bucket" kindref="compound">Bucket</ref></computeroutput> class, as well as the provided position (<computeroutput>pos</computeroutput>) and orientation (<computeroutput>ori</computeroutput>). <computeroutput>pos</computeroutput> and <computeroutput>ori</computeroutput> are used to apply the appropriate translation and rotation to the bucket relative to its reference pose. The centre of rotation is assumed to be the bucket origin. The orientation is provided using the quaternion definition. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.hpp" line="23" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.cpp" bodystart="22" bodyend="120" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.hpp" declline="23" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="body__pos_8hpp_1a2d02bdd842030a0b17b8587124b9fb6e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::CalcBodyPos</definition>
        <argsstring>(SimOut *sim_out, std::vector&lt; float &gt; pos, std::vector&lt; float &gt; ori, Grid grid, Blade *blade, SimParam sim_param, float tol)</argsstring>
        <name>CalcBodyPos</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>pos</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>ori</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_blade" kindref="compound">Blade</ref> *</type>
          <declname>blade</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_param" kindref="compound">SimParam</ref></type>
          <declname>sim_param</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function determines all the cells where the blade is located. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of the blade origin. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ori</parametername>
</parameternamelist>
<parameterdescription>
<para>Orientation of the blade. [Quaternion] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>blade</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the blade object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sim_param</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The blade position is calculated based on its reference pose stored in the <computeroutput><ref refid="classsoil__simulator_1_1_blade" kindref="compound">Blade</ref></computeroutput> class, as well as the provided position (<computeroutput>pos</computeroutput>) and orientation (<computeroutput>ori</computeroutput>). <computeroutput>pos</computeroutput> and <computeroutput>ori</computeroutput> are used to apply the appropriate translation and rotation to the blade relative to its reference pose. The centre of rotation is assumed to be the blade origin. The orientation is provided using the quaternion definition. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.hpp" line="36" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.cpp" bodystart="128" bodyend="268" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.hpp" declline="36" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="body__pos_8hpp_1a2179535c3816696c99c48313caf203f9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::vector&lt; int &gt; &gt;</type>
        <definition>std::vector&lt; std::vector&lt; int &gt; &gt; soil_simulator::CalcRectanglePos</definition>
        <argsstring>(std::vector&lt; float &gt; a, std::vector&lt; float &gt; b, std::vector&lt; float &gt; c, std::vector&lt; float &gt; d, Grid grid, float tol)</argsstring>
        <name>CalcRectanglePos</name>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>c</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>d</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function determines the cells where a rectangle surface is located. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of one vertex of the rectangle. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of one vertex of the rectangle. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of one vertex of the rectangle. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>d</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of one vertex of the rectangle. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Collection of cells indices where the rectangle is located. Result is not sorted and duplicates may be present.</para>
</simplesect>
The rectangle is defined by providing the Cartesian coordinates of its four vertices in the proper order.</para>
<para>To optimize performance, the function iterates over a portion of the horizontal grid where the rectangle is located. For each cell, the function calculates the height of the plane formed by the rectangle at the top right corner of the cell. If the cell is within the rectangle area, the calculated height is added to the results for the four neighbouring cells.</para>
<para>This method works because when a plane intersects with a rectangular cell, the minimum and maximum height of the plane within the cell occurs at one of the cell corners. By iterating through all the cells, the function ensures that all the corners of each cell are investigated.</para>
<para>However, this approach does not work when the rectangle is perpendicular to the XY plane. To handle this case, the function uses the <computeroutput>CalcLinePos</computeroutput> function to include the cells that lie on the four edges of the rectangle.</para>
<para>Note:<itemizedlist>
<listitem><para>The iteration is performed over the top right corner of each cell, but any other corner could have been chosen without affecting the results.</para>
</listitem><listitem><para>Not all cells are provided, since, at a given XY position, only the cells with the minimum and maximum height are important.</para>
</listitem><listitem><para>When the rectangle follows a cell border, the exact location of the rectangle becomes ambiguous. It is assumed that the caller resolves this ambiguity. </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.hpp" line="52" column="13" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.cpp" bodystart="296" bodyend="403" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.hpp" declline="52" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="body__pos_8hpp_1a548c40b2efad17e1de1cefd5213b180d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; std::vector&lt; std::vector&lt; float &gt; &gt;, std::vector&lt; std::vector&lt; float &gt; &gt;, std::vector&lt; std::vector&lt; bool &gt; &gt;, int &gt;</type>
        <definition>std::tuple&lt; std::vector&lt; std::vector&lt; float &gt; &gt;, std::vector&lt; std::vector&lt; float &gt; &gt;, std::vector&lt; std::vector&lt; bool &gt; &gt;, int &gt; soil_simulator::DecomposeVectorRectangle</definition>
        <argsstring>(std::vector&lt; float &gt; ab_ind, std::vector&lt; float &gt; ad_ind, std::vector&lt; float &gt; a_ind, int area_min_x, int area_min_y, int area_length_x, int area_length_y, float tol)</argsstring>
        <name>DecomposeVectorRectangle</name>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>ab_ind</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>ad_ind</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>a_ind</declname>
        </param>
        <param>
          <type>int</type>
          <declname>area_min_x</declname>
        </param>
        <param>
          <type>int</type>
          <declname>area_min_y</declname>
        </param>
        <param>
          <type>int</type>
          <declname>area_length_x</declname>
        </param>
        <param>
          <type>int</type>
          <declname>area_length_y</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function performs a vector decomposition on a portion of the horizontal plane where a rectangle ABCD is located. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ab_ind</parametername>
</parameternamelist>
<parameterdescription>
<para>Indices representing the edge AB of the rectangle. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ad_ind</parametername>
</parameternamelist>
<parameterdescription>
<para>Indices representing the edge AD of the rectangle. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_ind</parametername>
</parameternamelist>
<parameterdescription>
<para>Indices of the vertex A from which the edges AB and AD start. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>area_min_x</parametername>
</parameternamelist>
<parameterdescription>
<para>Minimum index in the X direction of the specified area. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>area_min_y</parametername>
</parameternamelist>
<parameterdescription>
<para>Minimum index in the Y direction of the specified area. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>area_length_x</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of grid elements in the X direction of the specified area. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>area_length_y</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of grid elements in the Y direction of the specified area. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A tuple composed of a vector of vector giving the vector decomposition in terms of the AB component, a vector of vector giving the vector decomposition in terms of the AD component, a vector of vector indicating whether the cell is inside the rectangle area, and the number of cells inside the rectangle area.</para>
</simplesect>
The position of the rectangle is defined by its edges AB and AD, while the specified area extends over [<computeroutput>area_min_x</computeroutput>, <computeroutput>area_min_x + area_length_x</computeroutput>] on the X direction and [<computeroutput>area_min_y</computeroutput>, <computeroutput>area_min_y + area_length_y</computeroutput>] on the Y direction.</para>
<para>For each cell in the specified area, the function decomposes it into the basis formed by the vectors AB and AD. Let O be the name of a cell, it can then be decomposed as</para>
<para><programlisting><codeline><highlight class="normal">AO<sp/>=<sp/>c_ab<sp/>*<sp/>AB<sp/>+<sp/>c_ad<sp/>*<sp/>AD.</highlight></codeline>
</programlisting></para>
<para>This decomposition leads to a system of 2 equations with 2 unknowns (c_ab and c_ad)</para>
<para><programlisting><codeline><highlight class="normal">AO[1]<sp/>=<sp/>c_ab<sp/>*<sp/>AB[1]<sp/>+<sp/>c_ad<sp/>*<sp/>AD[1]<sp/>{1},</highlight></codeline>
<codeline><highlight class="normal">AO[2]<sp/>=<sp/>c_ab<sp/>*<sp/>AB[2]<sp/>+<sp/>c_ad<sp/>*<sp/>AD[2]<sp/>{2}.</highlight></codeline>
</programlisting></para>
<para>One may note that AB[1] * {2} - AB[2] * {1} implies that</para>
<para><programlisting><codeline><highlight class="normal">AB[1]<sp/>*<sp/>AO[2]<sp/>-<sp/>AB[2]<sp/>*<sp/>AO[1]<sp/>=<sp/>c_ad<sp/>*<sp/>AD[2]<sp/>*<sp/>AB[1]<sp/>-<sp/>c_ad<sp/>*<sp/>AD[1]<sp/>*<sp/>AB[2]</highlight></codeline>
</programlisting></para>
<para>that can be further rewritten as</para>
<para><programlisting><codeline><highlight class="normal">c_ad<sp/>=<sp/>(AB[1]<sp/>*<sp/>AO[2]<sp/>-<sp/>AB[2]<sp/>*<sp/>AO[1])<sp/>/<sp/>(AD[2]<sp/>*<sp/>AB[1]<sp/>-<sp/>AD[1]<sp/>*<sp/>AB[2]).</highlight></codeline>
</programlisting></para>
<para>Similarly, AD[1] * {2} - AD[2] * {1} implies that</para>
<para><programlisting><codeline><highlight class="normal">c_ab<sp/>=<sp/>-(AD[1]<sp/>*<sp/>AO[2]<sp/>-<sp/>AD[2]<sp/>*<sp/>AO[1])<sp/>/<sp/>(AD[2]<sp/>*<sp/>AB[1]<sp/>-<sp/>AD[1]<sp/>*<sp/>AB[2]).</highlight></codeline>
</programlisting></para>
<para>This decomposition allows us to determine whether the cell O is inside the rectangle area, since this requires c_ab and c_ad to be between 0 and 1.</para>
<para>Note: By convention, the decomposition is done at the top right corner of each cell. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.hpp" line="78" column="1" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.cpp" bodystart="453" bodyend="498" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.hpp" declline="78" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="body__pos_8hpp_1a368a653cb44e842ab5be588a7a9ee7ec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::vector&lt; int &gt; &gt;</type>
        <definition>std::vector&lt; std::vector&lt; int &gt; &gt; soil_simulator::CalcTrianglePos</definition>
        <argsstring>(std::vector&lt; float &gt; a, std::vector&lt; float &gt; b, std::vector&lt; float &gt; c, Grid grid, float tol)</argsstring>
        <name>CalcTrianglePos</name>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>c</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function determines the cells where a triangle surface is located. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of one vertex of the triangle. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of one vertex of the triangle. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of one vertex of the triangle. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Collection of cells indices where the triangle is located. Result is not sorted and duplicates may be present.</para>
</simplesect>
The triangle is defined by providing the Cartesian coordinates of its three vertices in the proper order.</para>
<para>To optimize performance, the function iterates over a portion of the horizontal grid where the triangle is located. For each cell, the function calculates the height of the plane formed by the triangle at the top right corner of the cell. If the cell is within the triangle area, the calculated height is added to the results for the four neighbouring cells.</para>
<para>This method works because when a plane intersects with a rectangular cell, the minimum and maximum height of the plane within the cell occurs at one of the cell corners. By iterating through all the cells, the function ensures that all the corners of each cell are investigated.</para>
<para>However, this approach does not work when the triangle is perpendicular to the XY plane. To handle this case, the function uses the <computeroutput>CalcLinePos</computeroutput> function to include the cells that lie on the three edges of the triangle.</para>
<para>Note:<itemizedlist>
<listitem><para>The iteration is performed over the top right corner of each cell, but any other corner could have been chosen without affecting the results.</para>
</listitem><listitem><para>Not all cells are provided, since, at a given XY position, only the cells with the minimum and maximum height are important.</para>
</listitem><listitem><para>When the triangle follows a cell border, the exact location of the triangle becomes ambiguous. It is assumed that the caller resolves this ambiguity. </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.hpp" line="94" column="13" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.cpp" bodystart="526" bodyend="627" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.hpp" declline="94" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="body__pos_8hpp_1a324a3b394c8ea1a119572a05fddf37b8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; std::vector&lt; std::vector&lt; float &gt; &gt;, std::vector&lt; std::vector&lt; float &gt; &gt;, std::vector&lt; std::vector&lt; bool &gt; &gt;, int &gt;</type>
        <definition>std::tuple&lt; std::vector&lt; std::vector&lt; float &gt; &gt;, std::vector&lt; std::vector&lt; float &gt; &gt;, std::vector&lt; std::vector&lt; bool &gt; &gt;, int &gt; soil_simulator::DecomposeVectorTriangle</definition>
        <argsstring>(std::vector&lt; float &gt; ab_ind, std::vector&lt; float &gt; ac_ind, std::vector&lt; float &gt; a_ind, int area_min_x, int area_min_y, int area_length_x, int area_length_y, float tol)</argsstring>
        <name>DecomposeVectorTriangle</name>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>ab_ind</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>ac_ind</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>a_ind</declname>
        </param>
        <param>
          <type>int</type>
          <declname>area_min_x</declname>
        </param>
        <param>
          <type>int</type>
          <declname>area_min_y</declname>
        </param>
        <param>
          <type>int</type>
          <declname>area_length_x</declname>
        </param>
        <param>
          <type>int</type>
          <declname>area_length_y</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function performs a vector decomposition on a portion of the horizontal plane where a tritangle ABC is located. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ab_ind</parametername>
</parameternamelist>
<parameterdescription>
<para>Indices representing the edge AB of the triangle. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ac_ind</parametername>
</parameternamelist>
<parameterdescription>
<para>Indices representing the edge AC of the triangle. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_ind</parametername>
</parameternamelist>
<parameterdescription>
<para>Indices of the vertex A from which the edges AB and AC start. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>area_min_x</parametername>
</parameternamelist>
<parameterdescription>
<para>Minimum index in the X direction of the specified area. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>area_min_y</parametername>
</parameternamelist>
<parameterdescription>
<para>Minimum index in the Y direction of the specified area. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>area_length_x</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of grid elements in the X direction of the specified area. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>area_length_y</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of grid elements in the Y direction of the specified area. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A tuple composed of a vector of vector giving the vector decomposition in terms of the AB component, a vector of vector giving the vector decomposition in terms of the AC component, a vector of vector indicating whether the cell is inside the triangle area, and the number of cells inside the triangle area.</para>
</simplesect>
The position of the triangle is defined by its edges AB and AC, while the specified area extends over [<computeroutput>area_min_x</computeroutput>, <computeroutput>area_min_x + area_length_x</computeroutput>] on the X direction and [<computeroutput>area_min_y</computeroutput>, <computeroutput>area_min_y + area_length_y</computeroutput>] on the Y direction.</para>
<para>For each cell in the specified area, the function decomposes it into the basis formed by the vectors AB and AC. Let O be the name of a cell, it can then be decomposed as</para>
<para><programlisting><codeline><highlight class="normal">AO<sp/>=<sp/>c_ab<sp/>*<sp/>AB<sp/>+<sp/>c_ac<sp/>*<sp/>AC.</highlight></codeline>
</programlisting></para>
<para>This decomposition leads to a system of 2 equations with 2 unknowns (c_ab and c_ac)</para>
<para><programlisting><codeline><highlight class="normal">AO[1]<sp/>=<sp/>c_ab<sp/>*<sp/>AB[1]<sp/>+<sp/>c_ac<sp/>*<sp/>AC[1]<sp/>{1},</highlight></codeline>
<codeline><highlight class="normal">AO[2]<sp/>=<sp/>c_ab<sp/>*<sp/>AB[2]<sp/>+<sp/>c_ac<sp/>*<sp/>AC[2]<sp/>{2}.</highlight></codeline>
</programlisting></para>
<para>One may note that AB[1] * {2} - AB[2] * {1} implies that</para>
<para><programlisting><codeline><highlight class="normal">AB[1]<sp/>*<sp/>AO[2]<sp/>-<sp/>AB[2]<sp/>*<sp/>AO[1]<sp/>=<sp/>c_ac<sp/>*<sp/>AC[2]<sp/>*<sp/>AB[1]<sp/>-<sp/>c_ac<sp/>*<sp/>AC[1]<sp/>*<sp/>AB[2]</highlight></codeline>
</programlisting></para>
<para>that can be further rewritten as</para>
<para><programlisting><codeline><highlight class="normal">c_ac<sp/>=<sp/>(AB[1]<sp/>*<sp/>AO[2]<sp/>-<sp/>AB[2]<sp/>*<sp/>AO[1])<sp/>/<sp/>(AC[2]<sp/>*<sp/>AB[1]<sp/>-<sp/>AC[1]<sp/>*<sp/>AB[2]).</highlight></codeline>
</programlisting></para>
<para>Similarly, AC[1] * {2} - AC[2] * {1} implies that</para>
<para><programlisting><codeline><highlight class="normal">c_ab<sp/>=<sp/>-(AC[1]<sp/>*<sp/>AO[2]<sp/>-<sp/>AC[2]<sp/>*<sp/>AO[1])<sp/>/<sp/>(AC[2]<sp/>*<sp/>AB[1]<sp/>-<sp/>AC[1]<sp/>*<sp/>AB[2]).</highlight></codeline>
</programlisting></para>
<para>This decomposition allows us to determine whether the cell O is inside the triangle area, since this requires c_ab and c_ac to be between 0 and 1, and the sum of c_ab and c_ac to be lower than 1.</para>
<para>Note: By convention, the decomposition is done at the top right corner of each cell. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.hpp" line="120" column="1" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.cpp" bodystart="678" bodyend="723" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.hpp" declline="120" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="body__pos_8hpp_1a6b80177a1390bc07e10bfdaf0f7a594c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::vector&lt; int &gt; &gt;</type>
        <definition>std::vector&lt; std::vector&lt; int &gt; &gt; soil_simulator::CalcLinePos</definition>
        <argsstring>(std::vector&lt; float &gt; a, std::vector&lt; float &gt; b, Grid grid)</argsstring>
        <name>CalcLinePos</name>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <briefdescription>
<para>This function determines all the cells that lie on a straight line between two Cartesian coordinates. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of the first extremity of the line. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of the second extremity of the line. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Collection of cells indices where the line is located.</para>
</simplesect>
The algorithm implemented in this function comes from the article: &quot;A Fast Voxel Traversal Algorithm for Ray Tracing&quot; by J. Amanatides and A. Woo.</para>
<para>The floating-point values are rounded to obtain the cell indices in the X, Y, Z directions. As the centre of each cell is considered to be on the centre of the top surface, <computeroutput>round</computeroutput> should be used for getting the cell indices in the X and Y direction, while <computeroutput>ceil</computeroutput> should be used for the Z direction.</para>
<para>Note: When the line follows a cell border, the exact location of the line becomes ambiguous. It is assumed that the caller resolves this ambiguity. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.hpp" line="133" column="13" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.cpp" bodystart="738" bodyend="841" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.hpp" declline="133" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="body__pos_8hpp_1a04a0807350c0592bf1b49aa84dc672ef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::UpdateBody</definition>
        <argsstring>(std::vector&lt; std::vector&lt; int &gt;&gt; area_pos, SimOut *sim_out, Grid grid, float tol)</argsstring>
        <name>UpdateBody</name>
        <param>
          <type>std::vector&lt; std::vector&lt; int &gt;&gt;</type>
          <declname>area_pos</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function updates the body position in <computeroutput>body</computeroutput> following the cells composing <computeroutput>area_pos</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>area_pos</parametername>
</parameternamelist>
<parameterdescription>
<para>A collection of cell indices specifying where a body wall is located. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
For each XY position, the first cell found in <computeroutput>area_pos</computeroutput> corresponds to the minimum height of the body, while the last one provides the maximum height. As a result, this function must be called separately for each body wall and <computeroutput>area_pos</computeroutput> must be sorted. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.hpp" line="144" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.cpp" bodystart="847" bodyend="879" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.hpp" declline="144" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="body__pos_8hpp_1a3ea4ec8bd8dc0b85dbdec40a39442bcc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::IncludeNewBodyPos</definition>
        <argsstring>(SimOut *sim_out, int ii, int jj, float min_h, float max_h, float tol)</argsstring>
        <name>IncludeNewBodyPos</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ii</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jj</declname>
        </param>
        <param>
          <type>float</type>
          <declname>min_h</declname>
        </param>
        <param>
          <type>float</type>
          <declname>max_h</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function updates the body position in <computeroutput>body</computeroutput> at the coordinates (<computeroutput>ii</computeroutput>, <computeroutput>jj</computeroutput>). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ii</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered position in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jj</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered position in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>min_h</parametername>
</parameternamelist>
<parameterdescription>
<para>Minimum height of the body. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_h</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum height of the body. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The minimum and maximum heights of the body at that position are given by <computeroutput>min_h</computeroutput> and <computeroutput>max_h</computeroutput>, respectively. If the given position overlaps with an existing position, then the existing position is updated as the union of the two positions. Otherwise, a new position is added to <computeroutput>body_</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.hpp" line="156" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.cpp" bodystart="886" bodyend="977" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_pos.hpp" declline="156" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="body__soil_8hpp_1ac7f139a55ef6a55ead2ff719c34f9ccd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::UpdateBodySoil</definition>
        <argsstring>(SimOut *sim_out, std::vector&lt; float &gt; pos, std::vector&lt; float &gt; ori, Grid grid, Body *body, float tol)</argsstring>
        <name>UpdateBodySoil</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>pos</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>ori</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_body" kindref="compound">Body</ref> *</type>
          <declname>body</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function moves the soil resting on the body following its movement. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of the body origin. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ori</parametername>
</parameternamelist>
<parameterdescription>
<para>Orientation of the body. [Quaternion] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>body</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the body object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
In this function, the movement applied to the base of the soil column is calculated and the soil is moved to this new location. The original position of the soil column in the body frame is stored in the <computeroutput>body_soil_pos_</computeroutput> member of the <computeroutput><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref></computeroutput> class.</para>
<para>It is difficult to track accurately each body wall. This is currently done by determining the most likely location considering the movement made, and moving the soil to this location if the vertical distance is lower than a cell height. If it is not, the nine neighbouring cells are investigated. If no neighbouring cell has a body wall located at a distance lower than a cell height, the soil is moved to the cell with the lowest vertical distance. Note that it may still potentially lead to an incorrect choice.</para>
<para>If no body wall is present, the soil is moved down to the terrain and a warning is issued as it should normally not happen.</para>
<para>The new positions of the soil resting on the body are collected into <computeroutput>sim_out.body_soil_pos_</computeroutput> along with the required information using the <computeroutput><ref refid="structsoil__simulator_1_1body__soil" kindref="compound">body_soil</ref></computeroutput> struct. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_soil.hpp" line="23" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_soil.cpp" bodystart="35" bodyend="217" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/body_soil.hpp" declline="23" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="intersecting__cells_8hpp_1a965288fac7807774afec4ce12b330de2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::MoveIntersectingCells</definition>
        <argsstring>(SimOut *sim_out, Grid grid, Body *body, float tol)</argsstring>
        <name>MoveIntersectingCells</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_body" kindref="compound">Body</ref> *</type>
          <declname>body</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function moves all soil cells in <computeroutput>terrain_</computeroutput> and in <computeroutput>body_soil_</computeroutput> that intersect with the body or with another soil cell. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>body</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the body object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Note that <computeroutput>MoveIntersectingBodySoil</computeroutput> must be called before <computeroutput>MoveIntersectingBody</computeroutput>, otherwise some intersecting soil cells may remain. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/intersecting_cells.hpp" line="24" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/intersecting_cells.cpp" bodystart="19" bodyend="27" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/intersecting_cells.hpp" declline="24" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="intersecting__cells_8hpp_1a56cc5caa567355dbcf919630caa04926" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::MoveIntersectingBodySoil</definition>
        <argsstring>(SimOut *sim_out, Grid grid, Body *body, float tol)</argsstring>
        <name>MoveIntersectingBodySoil</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_body" kindref="compound">Body</ref> *</type>
          <declname>body</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function moves the soil cells resting on the body that intersect with another body layer. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>body</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the body object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function checks the eight lateral directions surrounding the intersecting soil column and moves the soil to available spaces.</para>
<para>The algorithm follows an incremental approach, checking directions farther from the intersecting soil column until it reaches a body wall blocking the movement or until all the soil has been moved. If the movement is blocked by a body wall, the algorithm explores another direction.</para>
<para>In cases where the soil should be moved to the terrain, all soil is moved regardless of the available space. If this movement induces intersecting soil cells, it will be resolved by the <computeroutput>MoveIntersectingBody</computeroutput> function.</para>
<para>In rare situations where there is insufficient space to accommodate all the intersecting soil, the algorithm currently handles it by allowing the excess soil to simply disappear. This compromise seems to be reasonable as long as the amount of soil disappearing remains negligible.</para>
<para>Note that the order in which the directions are checked is randomized in order to avoid asymmetrical results. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/intersecting_cells.hpp" line="34" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/intersecting_cells.cpp" bodystart="48" bodyend="161" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/intersecting_cells.hpp" declline="34" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="intersecting__cells_8hpp_1af3ee72c596b5a2a237b4b95f7ffe51a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::MoveIntersectingBody</definition>
        <argsstring>(SimOut *sim_out, float tol)</argsstring>
        <name>MoveIntersectingBody</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function moves the soil cells in the <computeroutput>terrain_</computeroutput> that intersect with a body. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function checks the eight lateral directions surrounding the intersecting soil column and moves the soil to available spaces. If there is insufficient space for all the soil, it incrementally checks the eight directions farther from the intersecting soil column until all the soil has been moved. The process can be illustrated as follows <verbatim>                  
                
              O  
                
                  
</verbatim> Note that the order in which the directions are checked is randomized in order to avoid asymmetrical results. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/intersecting_cells.hpp" line="42" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/intersecting_cells.cpp" bodystart="177" bodyend="276" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/intersecting_cells.hpp" declline="42" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="intersecting__cells_8hpp_1a8bf92ce733503a60193a92ca5c65ee3d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; int, int, int, float, bool &gt;</type>
        <definition>std::tuple&lt; int, int, int, float, bool &gt; soil_simulator::MoveBodySoil</definition>
        <argsstring>(SimOut *sim_out, int ind_p, int ii_p, int jj_p, float max_h, int ii_n, int jj_n, float h_soil, bool wall_presence, Grid grid, Body *body, float tol)</argsstring>
        <name>MoveBodySoil</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ind_p</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ii_p</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jj_p</declname>
        </param>
        <param>
          <type>float</type>
          <declname>max_h</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ii_n</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jj_n</declname>
        </param>
        <param>
          <type>float</type>
          <declname>h_soil</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>wall_presence</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_body" kindref="compound">Body</ref> *</type>
          <declname>body</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function tries to move the soil cells resting on the body layer <computeroutput>ind_p</computeroutput> at the location (<computeroutput>ii_p</computeroutput>, <computeroutput>jj_p</computeroutput>) to a new location at (<computeroutput>ii_n</computeroutput>, <computeroutput>jj_n</computeroutput>). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ind_p</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the previous considered body layer. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ii_p</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the previous considered position in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jj_p</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the previous considered position in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_h</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum height authorized for the movement. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ii_n</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the new considered position in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jj_n</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the new considered position in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>h_soil</parametername>
</parameternamelist>
<parameterdescription>
<para>Height of the soil column left to be moved. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>wall_presence</parametername>
</parameternamelist>
<parameterdescription>
<para>Indicates whether a wall is blocking the movement. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>body</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the body object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A tuple composed of the index of the new considered body layer, the index of the new considered position in the X direction, the index of the new considered position in the Y direction, the height of the soil column left to be moved, and a boolean indicating whether a body wall is blocking the movement.</para>
</simplesect>
This function can be separated into three main scenarios:<itemizedlist>
<listitem><para>If all the soil can be moved to the new location (either on the terrain or on the body), the soil is moved and the value of <computeroutput>h_soil</computeroutput> is set to zero.</para>
</listitem><listitem><para>If a body wall is blocking the movement, the <computeroutput>wall_presence</computeroutput> parameter is set to <computeroutput>true</computeroutput>.</para>
</listitem><listitem><para>If there is insufficient space to move all the soil but no body wall is blocking the movement, the function updates the values for the new location and adjusts <computeroutput>h_soil</computeroutput> accordingly.</para>
</listitem></itemizedlist>
</para>
<para>This function is designed to be used iteratively by the function <computeroutput>MoveIntersectingBodySoil</computeroutput> until all intersecting soil cells are moved.</para>
<para>Note that, by convention, the soil can be moved from the body to the terrain even if the body is underground. Moreover, in cases where the soil should be moved to the terrain, all soil is moved regardless of the available space. If this movement induces intersecting soil cells, it will be resolved by <computeroutput>MoveIntersectingBody</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/intersecting_cells.hpp" line="66" column="12" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/intersecting_cells.cpp" bodystart="296" bodyend="508" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/intersecting_cells.hpp" declline="66" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="intersecting__cells_8hpp_1a440356f5f2e5b422bf5ba55bb8b74d47" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::vector&lt; int &gt; &gt;</type>
        <definition>std::vector&lt; std::vector&lt; int &gt; &gt; soil_simulator::LocateIntersectingCells</definition>
        <argsstring>(SimOut *sim_out, float tol)</argsstring>
        <name>LocateIntersectingCells</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function identifies all the soil cells in the <computeroutput>terrain_</computeroutput> that intersect with the body. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/intersecting_cells.hpp" line="76" column="13" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/intersecting_cells.cpp" bodystart="510" bodyend="540" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/intersecting_cells.hpp" declline="76" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="relax_8hpp_1a6b692a3224f7b4050c16fc47fc3f9b71" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::RelaxTerrain</definition>
        <argsstring>(SimOut *sim_out, Grid grid, Body *body, SimParam sim_param, float tol)</argsstring>
        <name>RelaxTerrain</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_body" kindref="compound">Body</ref> *</type>
          <declname>body</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_param" kindref="compound">SimParam</ref></type>
          <declname>sim_param</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function moves the soil in <computeroutput>terrain_</computeroutput> towards a state closer to equilibrium. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>body</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the body object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sim_param</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The soil stability is determined by the <computeroutput>repose_angle_</computeroutput>. If the slope formed by two neighbouring soil columns exceeds the <computeroutput>repose_angle_</computeroutput>, it is considered unstable, and the soil from the higher column should avalanche to the neighbouring column to reach an equilibrium state.</para>
<para>By convention, this function only checks the stability of the soil in the four adjacent cells:   O  </para>
<para>The diagonal directions are not checked for simplicity and performance reasons.</para>
<para>This function only moves the soil when the following conditions are met:</para>
<para>(1) The soil column in the neighbouring cell is low enough. (2) Either: (a) The body is not on the soil, meaning there is space between the <computeroutput>terrain_</computeroutput> and the body, or there is no body. (b) The body is on the <computeroutput>terrain_</computeroutput>, but the combination of the body and body soil is not high enough to prevent soil avalanche.</para>
<para>In case (2a), the soil will avalanche on the <computeroutput>terrain_</computeroutput>, while in case (2b), the soil will avalanche on the body. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/relax.hpp" line="24" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/relax.cpp" bodystart="42" bodyend="137" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/relax.hpp" declline="24" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="relax_8hpp_1a53ff3f7ed299dec1cf199c8e563d2039" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::RelaxBodySoil</definition>
        <argsstring>(SimOut *sim_out, Grid grid, Body *body, SimParam sim_param, float tol)</argsstring>
        <name>RelaxBodySoil</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_body" kindref="compound">Body</ref> *</type>
          <declname>body</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_param" kindref="compound">SimParam</ref></type>
          <declname>sim_param</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function moves the soil in <computeroutput>body_soil_</computeroutput> towards a state closer to equilibrium. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>body</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the body object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sim_param</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The soil stability is determined by the <computeroutput>repose_angle_</computeroutput>. If the slope formed by two neighbouring soil columns exceeds the <computeroutput>repose_angle_</computeroutput>, it is considered unstable, and the soil from the higher column should avalanche to the neighbouring column to reach an equilibrium state.</para>
<para>By convention, this function only checks the stability of the soil in the four adjacent cells:   O  </para>
<para>The diagonal directions are not checked for simplicity and performance reasons.</para>
<para>This function only moves the soil when the following conditions are met:</para>
<para>(1) The soil column in the neighbouring cell is low enough. (2) There is space on the top of the neighbouring soil column. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/relax.hpp" line="35" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/relax.cpp" bodystart="157" bodyend="229" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/relax.hpp" declline="35" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="relax_8hpp_1a0a8c6ad78abd12190ab2b54483ce7bf6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::vector&lt; int &gt; &gt;</type>
        <definition>std::vector&lt; std::vector&lt; int &gt; &gt; soil_simulator::LocateUnstableTerrainCell</definition>
        <argsstring>(SimOut *sim_out, float dh_max, float tol)</argsstring>
        <name>LocateUnstableTerrainCell</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>float</type>
          <declname>dh_max</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function locates all the cells in <computeroutput>terrain_</computeroutput> that have a height difference larger than <computeroutput>dh_max</computeroutput> with at least one neighbouring cell. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dh_max</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum height difference allowed between two neighbouring cells. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Collection of cells indices that are possibly unstable.</para>
</simplesect>
It is important to note that the cells selected by this function are not necessarily unstable, as a body or the soil resting on it could be supporting the soil column. This is only a first-order selection of cells potentially unstable. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/relax.hpp" line="47" column="13" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/relax.cpp" bodystart="235" bodyend="264" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/relax.hpp" declline="47" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="relax_8hpp_1ab7ab093b938d3cd2678a004f26fdb7e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int soil_simulator::CheckUnstableTerrainCell</definition>
        <argsstring>(SimOut *sim_out, int ii_c, int jj_c, float h_min, float tol)</argsstring>
        <name>CheckUnstableTerrainCell</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ii_c</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jj_c</declname>
        </param>
        <param>
          <type>float</type>
          <declname>h_min</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function checks the stability of a soil column in <computeroutput>terrain_</computeroutput> compared to one of its neighbour (<computeroutput>ii_c</computeroutput>, <computeroutput>jj_c</computeroutput>) </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ii_c</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the neighbouring cell in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jj_c</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the neighbouring cell in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>h_min</parametername>
</parameternamelist>
<parameterdescription>
<para>Minimum allowed height for a stable configuration. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Two-digit number indicating how the soil should avalanche. <computeroutput>0</computeroutput> is returned if the soil column is stable.</para>
</simplesect>
In case of instability, this function returns a two-digit number (<computeroutput>status</computeroutput>) that provides information on how the soil should avalanche. The interpretation of the two-digit number is described below.</para>
<para>The first digit indicates the potential presence of the body:<itemizedlist>
<listitem><para>1 when the first body layer is present.</para>
</listitem><listitem><para>2 when the second body layer is present.</para>
</listitem><listitem><para>3 when the two body layers are present.</para>
</listitem><listitem><para>4 when no body layer is present.</para>
</listitem></itemizedlist>
</para>
<para>The second digit indicates the layer where the soil should avalanche:<itemizedlist>
<listitem><para>0 when it is the terrain` (no body is present).</para>
</listitem><listitem><para>1 when it is the second body soil layer.</para>
</listitem><listitem><para>2 when it is the second body layer.</para>
</listitem><listitem><para>3 when it is the first body soil layer.</para>
</listitem><listitem><para>4 when it is the first body layer.</para>
</listitem></itemizedlist>
</para>
<para>The combination of these two digits provides a comprehensive description of how the soil should avalanche in different scenarios.</para>
<para>Note that not all combinations for <computeroutput>status</computeroutput> are possible. Some combinations, such as <computeroutput>41</computeroutput> or <computeroutput>23</computeroutput> are impossible. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/relax.hpp" line="61" column="5" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/relax.cpp" bodystart="288" bodyend="418" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/relax.hpp" declline="61" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="relax_8hpp_1a846b24cfecc8f7c152a08debe27953c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int soil_simulator::CheckUnstableBodyCell</definition>
        <argsstring>(SimOut *sim_out, int ii, int jj, int ind, int ii_c, int jj_c, float h_min, float tol)</argsstring>
        <name>CheckUnstableBodyCell</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ii</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jj</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ind</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ii_c</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jj_c</declname>
        </param>
        <param>
          <type>float</type>
          <declname>h_min</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function checks the stability of a soil column in the soil layer <computeroutput>ind</computeroutput> of <computeroutput>body_soil_</computeroutput> at (<computeroutput>ii</computeroutput>, <computeroutput>jj</computeroutput>) compared to one of its neighbour at (<computeroutput>ii_c</computeroutput>, <computeroutput>jj_c</computeroutput>). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ii</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered cell in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jj</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered cell in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ind</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered soil layer. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ii_c</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the neighbouring cell in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jj_c</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the neighbouring cell in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>h_min</parametername>
</parameternamelist>
<parameterdescription>
<para>Minimum allowed height for a stable configuration. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Two-digit number indicating how the soil should avalanche. <computeroutput>0</computeroutput> is returned if the soil column is stable.</para>
</simplesect>
In case of instability, this function returns a two-digit number (<computeroutput>status</computeroutput>) that provides information on how the soil should avalanche. The interpretation of the two-digit number is described below.</para>
<para>The first digit indicates the potential presence of the body:<itemizedlist>
<listitem><para>1 when the first body layer is present.</para>
</listitem><listitem><para>2 when the second body layer is present.</para>
</listitem><listitem><para>3 when the two body layers are present.</para>
</listitem><listitem><para>4 when no body layer is present.</para>
</listitem></itemizedlist>
</para>
<para>The second digit indicates the layer where the soil should avalanche:<itemizedlist>
<listitem><para>0 when it is the terrain (no body is present).</para>
</listitem><listitem><para>1 when it is the second body soil layer.</para>
</listitem><listitem><para>2 when it is the second body layer.</para>
</listitem><listitem><para>3 when it is the first body soil layer.</para>
</listitem><listitem><para>4 when it is the first body layer.</para>
</listitem></itemizedlist>
</para>
<para>The combination of these two digits provides a comprehensive description of how the soil should avalanche in different scenarios.</para>
<para>Note that not all combinations for <computeroutput>status</computeroutput> are possible. Some combinations, such as <computeroutput>41</computeroutput> or <computeroutput>23</computeroutput> are impossible. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/relax.hpp" line="79" column="5" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/relax.cpp" bodystart="442" bodyend="575" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/relax.hpp" declline="79" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="relax_8hpp_1af47f4adef51d95eb437e754502eb0f15" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::RelaxUnstableTerrainCell</definition>
        <argsstring>(SimOut *sim_out, int status, float dh_max, int ii, int jj, int ii_c, int jj_c, Grid grid, Body *body, float tol)</argsstring>
        <name>RelaxUnstableTerrainCell</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>int</type>
          <declname>status</declname>
        </param>
        <param>
          <type>float</type>
          <declname>dh_max</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ii</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jj</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ii_c</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jj_c</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_body" kindref="compound">Body</ref> *</type>
          <declname>body</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function moves the soil from the <computeroutput>terrain_</computeroutput> at (<computeroutput>ii</computeroutput>, <computeroutput>jj</computeroutput>) to the soil column in (<computeroutput>ii_c</computeroutput>, <computeroutput>jj_c</computeroutput>). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>status</parametername>
</parameternamelist>
<parameterdescription>
<para>Two-digit number indicating how the soil should avalanche. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dh_max</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum height difference allowed between two neighbouring cells. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ii</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered cell in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jj</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered cell in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ii_c</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the neighbouring cell in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jj_c</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the neighbouring cell in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>body</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the body object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The precise movement applied to the soil cell depends on the <computeroutput>status</computeroutput> number provided by the <computeroutput>CheckUnstableTerrainCell</computeroutput> function.</para>
<para>The soil is moved such that the slope formed by the two neighbouring soil columns is equal to the <computeroutput>repose_angle_</computeroutput>. When the body is preventing this configuration, the soil avalanche below the body to fill the space under it.</para>
<para>Note that it is assumed that the given <computeroutput>status</computeroutput> is accurate, so no extra checks are present. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/relax.hpp" line="97" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/relax.cpp" bodystart="587" bodyend="789" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/relax.hpp" declline="97" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="relax_8hpp_1af6199df3c1fc8770b2891c45e5e45b09" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::RelaxUnstableBodyCell</definition>
        <argsstring>(SimOut *sim_out, int status, std::vector&lt; body_soil &gt; *body_soil_pos, float dh_max, int nn, int ii, int jj, int ind, int ii_c, int jj_c, Grid grid, Body *body, float tol)</argsstring>
        <name>RelaxUnstableBodyCell</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>int</type>
          <declname>status</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="structsoil__simulator_1_1body__soil" kindref="compound">body_soil</ref> &gt; *</type>
          <declname>body_soil_pos</declname>
        </param>
        <param>
          <type>float</type>
          <declname>dh_max</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nn</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ii</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jj</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ind</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ii_c</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jj_c</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_body" kindref="compound">Body</ref> *</type>
          <declname>body</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function moves the soil from the soil layer <computeroutput>ind</computeroutput> of <computeroutput>body_soil_</computeroutput> at (<computeroutput>ii</computeroutput>, <computeroutput>jj</computeroutput>) to the soil column in (<computeroutput>ii_c</computeroutput>, <computeroutput>jj_c</computeroutput>). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>status</parametername>
</parameternamelist>
<parameterdescription>
<para>Two-digit number indicating how the soil should avalanche. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>body_soil_pos</parametername>
</parameternamelist>
<parameterdescription>
<para>Queue to append new body_soil_pos. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dh_max</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum height difference allowed between two neighbouring cells. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nn</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered soil in <computeroutput>body_soil_pos_</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ii</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered cell in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jj</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered cell in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ind</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered soil layer. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ii_c</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the neighbouring cell in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jj_c</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the neighbouring cell in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>body</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the body object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The precise movement applied to the soil cell depends on the <computeroutput>status</computeroutput> number provided by the <computeroutput>CheckUnstableBodyCell</computeroutput> function.</para>
<para>The soil is moved such that the slope formed by the two neighbouring soil columns is equal to the <computeroutput>repose_angle_</computeroutput>, provided that the body is not preventing this configuration.</para>
<para>Note that it is assumed that the given <computeroutput>status</computeroutput> is accurate, so no extra checks are present. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/relax.hpp" line="118" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/relax.cpp" bodystart="800" bodyend="1290" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/relax.hpp" declline="118" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="utils_8hpp_1a996f3a275167d5fd9d7aa53c90421dfc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; std::vector&lt; float &gt;, std::vector&lt; float &gt;, std::vector&lt; float &gt;, std::vector&lt; float &gt;, std::vector&lt; float &gt;, std::vector&lt; float &gt; &gt;</type>
        <definition>std::tuple&lt; std::vector&lt; float &gt;, std::vector&lt; float &gt;, std::vector&lt; float &gt;, std::vector&lt; float &gt;, std::vector&lt; float &gt;, std::vector&lt; float &gt; &gt; soil_simulator::CalcBodyCornerPos</definition>
        <argsstring>(std::vector&lt; float &gt; pos, std::vector&lt; float &gt; ori, Body *body)</argsstring>
        <name>CalcBodyCornerPos</name>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>pos</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>ori</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_body" kindref="compound">Body</ref> *</type>
          <declname>body</declname>
        </param>
        <briefdescription>
<para>This function calculates the global position of the six corners of the body. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of the body origin. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ori</parametername>
</parameternamelist>
<parameterdescription>
<para>Orientation of the body. [Quaternion] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>body</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the body object.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A tuple composed of six vectors giving the Cartesian coordinates of the body corners in that order: right side of the body joint, left side of the body joint, right side of the body base, left side of the body base, right side of the body teeth, left side of the body teeth. [m] </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" line="29" column="1" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.cpp" bodystart="20" bodyend="58" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" declline="29" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="utils_8hpp_1aaf5fe0d8d7e1aa77d8e634d436e1c4ac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool soil_simulator::CheckBodyMovement</definition>
        <argsstring>(std::vector&lt; float &gt; pos, std::vector&lt; float &gt; ori, Grid grid, Body *body)</argsstring>
        <name>CheckBodyMovement</name>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>pos</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>ori</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_body" kindref="compound">Body</ref> *</type>
          <declname>body</declname>
        </param>
        <briefdescription>
<para>This function calculates how far the body has travelled since the last soil update and checks whether it is necessary to update the soil. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of the body origin. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ori</parametername>
</parameternamelist>
<parameterdescription>
<para>Orientation of the body. [Quaternion] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>body</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the body object.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A boolean indicating whether the soil should be updated.</para>
</simplesect>
This function calculates the maximum distance travelled by any part of the body since the last soil update. The position of the body during the last soil update is stored in the <computeroutput>body</computeroutput> class.</para>
<para>If the maximum distance travelled is lower than 50% of the cell size, the function returns <computeroutput>false</computeroutput> otherwise it returns <computeroutput>true</computeroutput>. Note that if the distance travelled exceeds twice the cell size, a warning is issued to indicate a potential problem with the soil update. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" line="42" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.cpp" bodystart="68" bodyend="121" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" declline="42" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="utils_8hpp_1a0647bb972b73b90dffefed418fe8afc6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; float &gt;</type>
        <definition>std::vector&lt; float &gt; soil_simulator::CalcNormal</definition>
        <argsstring>(std::vector&lt; float &gt; a, std::vector&lt; float &gt; b, std::vector&lt; float &gt; c)</argsstring>
        <name>CalcNormal</name>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>This function calculates the unit normal vector of a plane formed by three points using the right-hand rule. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of the first point of the plane. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of the second point of the plane. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of the third point of the plane. [m]</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Unit normal vector of the provided plane. [m] </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" line="53" column="13" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.cpp" bodystart="123" bodyend="143" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" declline="53" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="utils_8hpp_1aa9525329b594eba87d2eff0ea0e37b43" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; float &gt;</type>
        <definition>std::vector&lt; float &gt; soil_simulator::CalcBodyFramePos</definition>
        <argsstring>(int ii, int jj, float z, Grid grid, Body *body)</argsstring>
        <name>CalcBodyFramePos</name>
        <param>
          <type>int</type>
          <declname>ii</declname>
        </param>
        <param>
          <type>int</type>
          <declname>jj</declname>
        </param>
        <param>
          <type>float</type>
          <declname>z</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_body" kindref="compound">Body</ref> *</type>
          <declname>body</declname>
        </param>
        <briefdescription>
<para>This function calculates the position of a considered cell in the body frame assuming that the body is in its reference position. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ii</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered cell in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>jj</parametername>
</parameternamelist>
<parameterdescription>
<para>Index of the considered cell in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>Height of the considered position. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>body</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the body object.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Cartesian coordinates of the considered position in the reference body frame. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" line="67" column="13" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.cpp" bodystart="145" bodyend="163" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" declline="67" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="utils_8hpp_1a1f96f36b03ea5e7fd7acf8774a346350" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; float &gt;</type>
        <definition>std::vector&lt; float &gt; soil_simulator::CalcRotationQuaternion</definition>
        <argsstring>(std::vector&lt; float &gt; ori, std::vector&lt; float &gt; pos)</argsstring>
        <name>CalcRotationQuaternion</name>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>ori</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>pos</declname>
        </param>
        <briefdescription>
<para>This function applies a rotation <computeroutput>ori</computeroutput> to the Cartesian coordinates <computeroutput>pos</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>The Quaternion convention is used for 3D rotation.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ori</parametername>
</parameternamelist>
<parameterdescription>
<para>Orientation of the body. [Quaternion] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pos</parametername>
</parameternamelist>
<parameterdescription>
<para>Cartesian coordinates of one point of the body in its reference pose relative to the body origin. [m]</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Rotated Cartesian coordinates of the input <computeroutput>pos</computeroutput> relative to the body origin. [m]</para>
</simplesect>
The mathematical reasoning behind this implementation can be easily found in the Wiki page of Quaternion or elsewhere. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" line="81" column="13" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.cpp" bodystart="167" bodyend="184" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" declline="81" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="utils_8hpp_1acd568e6b041aae700f5e1b915c8d90e7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; float &gt;</type>
        <definition>std::vector&lt; float &gt; soil_simulator::AngleToQuat</definition>
        <argsstring>(std::vector&lt; float &gt; ori)</argsstring>
        <name>AngleToQuat</name>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>ori</declname>
        </param>
        <briefdescription>
<para>This function converts Euler angles following the ZYX convention to a quaternion. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ori</parametername>
</parameternamelist>
<parameterdescription>
<para>Orientation of the body. [Euler angles, ZYX sequence]</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Orientation of the body. [Quaternion]</para>
</simplesect>
The mathematical reasoning behind this implementation can be easily found in the Wiki page of Quaternion or elsewhere.</para>
<para>Note that this function only works if the Euler angles follow the ZYX convention. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" line="90" column="13" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.cpp" bodystart="191" bodyend="217" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" declline="90" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="utils_8hpp_1a65d6a37c7717cf60059c53d09e684532" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; float &gt;</type>
        <definition>std::vector&lt; float &gt; soil_simulator::MultiplyQuaternion</definition>
        <argsstring>(std::vector&lt; float &gt; q1, std::vector&lt; float &gt; q2)</argsstring>
        <name>MultiplyQuaternion</name>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>q1</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt;</type>
          <declname>q2</declname>
        </param>
        <briefdescription>
<para>This function calculates the product of two quaternions. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>q1</parametername>
</parameternamelist>
<parameterdescription>
<para>First quaternion. [Quaternion] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>q2</parametername>
</parameternamelist>
<parameterdescription>
<para>Second quaternion. [Quaternion]</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Product of the two inputs quaternions. [Quaternion]</para>
</simplesect>
The mathematical reasoning behind this implementation can be easily found in the Wiki page of Quaternion or elsewhere. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" line="98" column="13" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.cpp" bodystart="221" bodyend="234" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" declline="98" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="utils_8hpp_1ab3b3594a04edeb366a2be6231b8b7a08" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool soil_simulator::CheckVolume</definition>
        <argsstring>(SimOut *sim_out, int init_volume, Grid grid, float tol)</argsstring>
        <name>CheckVolume</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>int</type>
          <declname>init_volume</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function checks that the volume of soil is conserved and that the content of <computeroutput>body_soil_pos_</computeroutput> and <computeroutput>body_soil_</computeroutput> is consistent. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init_volume</parametername>
</parameternamelist>
<parameterdescription>
<para>Initial number of soil cells. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Boolean indicating whether soil is conserved or not.</para>
</simplesect>
The initial number of soil cells (<computeroutput>init_volume</computeroutput>) has to be provided. The number of soil cells is used instead of volume in order to avoid issue due to floating number approximation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" line="110" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.cpp" bodystart="239" bodyend="312" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" declline="110" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="utils_8hpp_1a79a35e16ac590fb4b828ea43c7f5b891" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool soil_simulator::CheckSoil</definition>
        <argsstring>(SimOut *sim_out, float tol)</argsstring>
        <name>CheckSoil</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type>float</type>
          <declname>tol</declname>
        </param>
        <briefdescription>
<para>This function checks that all the simulation outputs follow the conventions of the simulator. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tol</parametername>
</parameternamelist>
<parameterdescription>
<para>Small number used to handle numerical approximation errors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Boolean indicating whether the simulation outputs are consistent.</para>
</simplesect>
The conventions that are checked by this function include:<itemizedlist>
<listitem><para>The terrain should not overlap with the body.</para>
</listitem><listitem><para>The body should be properly defined, with its maximum height higher than its minimum height.</para>
</listitem><listitem><para>The body soil should be properly defined, with its maximum height higher than its minimum height.</para>
</listitem><listitem><para>The two body layers should not overlap or touch each other.</para>
</listitem><listitem><para>One body layer should not overlap with all body soil layer.</para>
</listitem><listitem><para>The body should not overlap with the corresponding body soil layer.</para>
</listitem><listitem><para>The body soil layer should be resting on the corresponding body layer.</para>
</listitem><listitem><para>The body should be present when there is body soil. </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" line="119" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.cpp" bodystart="325" bodyend="488" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" declline="119" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="utils_8hpp_1a3a1312acf11adcd75455909ec81fceb7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::WriteSoil</definition>
        <argsstring>(SimOut *sim_out, Grid grid)</argsstring>
        <name>WriteSoil</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_sim_out" kindref="compound">SimOut</ref> *</type>
          <declname>sim_out</declname>
        </param>
        <param>
          <type><ref refid="classsoil__simulator_1_1_grid" kindref="compound">Grid</ref></type>
          <declname>grid</declname>
        </param>
        <briefdescription>
<para>This function writes the terrain and the body soil into a csv located in the <computeroutput>results</computeroutput> directory. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sim_out</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores simulation outputs. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the simulation grid.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<computeroutput>terrain_</computeroutput> and <computeroutput>body_soil_</computeroutput> are saved into files named <computeroutput>terrain</computeroutput> and <computeroutput><ref refid="structsoil__simulator_1_1body__soil" kindref="compound">body_soil</ref></computeroutput>, respectively, followed by the file number. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" line="126" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.cpp" bodystart="492" bodyend="565" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" declline="126" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="utils_8hpp_1a3230b79b33d5e40b53b8f009ff4cb085" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::WriteBody</definition>
        <argsstring>(Bucket *bucket)</argsstring>
        <name>WriteBody</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_bucket" kindref="compound">Bucket</ref> *</type>
          <declname>bucket</declname>
        </param>
        <briefdescription>
<para>This function writes the position of all bucket faces into a csv located in the <computeroutput>results</computeroutput> directory. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>bucket</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the bucket object.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The bucket corners are saved into a file named <computeroutput>bucket</computeroutput> followed by the file number. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" line="132" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.cpp" bodystart="569" bodyend="638" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" declline="132" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="utils_8hpp_1a30a7355137ff3894de406a9fc100e1f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void soil_simulator::WriteBody</definition>
        <argsstring>(Blade *blade)</argsstring>
        <name>WriteBody</name>
        <param>
          <type><ref refid="classsoil__simulator_1_1_blade" kindref="compound">Blade</ref> *</type>
          <declname>blade</declname>
        </param>
        <briefdescription>
<para>This function writes the position of all blade faces into a csv located in the <computeroutput>results</computeroutput> directory. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>blade</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the blade object.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The blade corners are saved into a file named <computeroutput>blade</computeroutput> followed by the file number. Note that only the corners from the front of the blade are written. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" line="138" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.cpp" bodystart="643" bodyend="698" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" declline="138" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="utils_8hpp_1a49474b2c040ba18a18540424f4a72819" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>float</type>
        <definition>float soil_simulator::simplex_noise</definition>
        <argsstring>(float x, float y, std::vector&lt; int &gt; perm_table)</argsstring>
        <name>simplex_noise</name>
        <param>
          <type>float</type>
          <declname>x</declname>
        </param>
        <param>
          <type>float</type>
          <declname>y</declname>
        </param>
        <param>
          <type>std::vector&lt; int &gt;</type>
          <declname>perm_table</declname>
        </param>
        <briefdescription>
<para>This function creates simplex noise for more realistic terrain generation. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Rescaled Cartesian coordinate in the X direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>Rescaled Cartesian coordinate in the Y direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>perm_table</parametername>
</parameternamelist>
<parameterdescription>
<para>Pre-calculated permutation table to generate pseudo-random noise.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A float representing the Simplex noise.</para>
</simplesect>
This function implements 2D Simplex noise. A lot of material can be found online concerning this implementation so that the details would not be explicited here. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" line="149" column="7" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.cpp" bodystart="703" bodyend="771" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/utils.hpp" declline="149" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="soil__evolution_8hpp_1ad228053ff524a789f0007769aa28ff44" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void soil_simulator::SoilEvolution</definition>
        <argsstring>(T *body, bool set_rng, bool random_trajectory, bool logging, bool check_outputs, bool write_outputs)</argsstring>
        <name>SoilEvolution</name>
        <param>
          <type>T *</type>
          <declname>body</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>set_rng</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>random_trajectory</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>logging</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>check_outputs</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>write_outputs</declname>
        </param>
        <briefdescription>
<para>This function provides an example script to run the simulator. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>body</parametername>
</parameternamelist>
<parameterdescription>
<para>Class that stores information related to the body object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>set_rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Indicates whether the RNG seed is set or not. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>random_trajectory</parametername>
</parameternamelist>
<parameterdescription>
<para>Indicates whether the default trajectory or a randomized one is used. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>logging</parametername>
</parameternamelist>
<parameterdescription>
<para>Indicates whether logging information are provided. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>check_outputs</parametername>
</parameternamelist>
<parameterdescription>
<para>Indicates whether to run simulation outputs check at every step. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>write_outputs</parametername>
</parameternamelist>
<parameterdescription>
<para>Indicates whether the simulation outputs are written into files at every step.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This example script simulates either a bucket performing a simple digging scoop in the XZ plane following a parabolic trajectory, or a blade performing a soil pushing in the XZ plane following a slightly parabolic trajectory. There is an option to randomize the parabolic trajectory by selecting the initial position (<computeroutput>x_i</computeroutput>, <computeroutput>z_i</computeroutput>) of the body and the deepest point of the trajectory (<computeroutput>x_min</computeroutput>, <computeroutput>z_min</computeroutput>) within reasonable ranges.</para>
<para>Note that the parabolic trajectory assumes that the orientation of the bucket follows the gradient of the trajectory. While it may not be fully accurate, it provides a good approximation for testing the simulator. By contrast, the blade keeps the same orientation throughout the trajectory. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/test/example/soil_evolution.hpp" line="25" column="6" bodyfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/test/example/soil_evolution.cpp" bodystart="33" bodyend="335" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/test/example/soil_evolution.hpp" declline="25" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="soil__evolution_8hpp_1aa35555d66b277c532fedcee36e34a40d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::tuple&lt; std::vector&lt; std::vector&lt; float &gt; &gt;, std::vector&lt; std::vector&lt; float &gt; &gt;&gt;</type>
        <definition>std::tuple&lt; std::vector&lt;std::vector&lt;float&gt; &gt;, std::vector&lt;std::vector&lt;float&gt; &gt;&gt; soil_simulator::CalcTrajectory</definition>
        <argsstring>(float x_i, float z_i, float x_min, float z_min, float origin_angle, int nn)</argsstring>
        <name>CalcTrajectory</name>
        <param>
          <type>float</type>
          <declname>x_i</declname>
        </param>
        <param>
          <type>float</type>
          <declname>z_i</declname>
        </param>
        <param>
          <type>float</type>
          <declname>x_min</declname>
        </param>
        <param>
          <type>float</type>
          <declname>z_min</declname>
        </param>
        <param>
          <type>float</type>
          <declname>origin_angle</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nn</declname>
        </param>
        <briefdescription>
<para>This function calculates a parabolic trajectory given the starting position (<computeroutput>x_i</computeroutput>, <computeroutput>z_i</computeroutput>) and the deepest position (<computeroutput>x_min</computeroutput>, <computeroutput>z_min</computeroutput>) of the trajectory. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x_i</parametername>
</parameternamelist>
<parameterdescription>
<para>X coordinate of the starting position of the trajectory. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z_i</parametername>
</parameternamelist>
<parameterdescription>
<para>Z coordinate of the starting position of the trajectory. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x_min</parametername>
</parameternamelist>
<parameterdescription>
<para>X coordinate of the deepest position of the trajectory. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z_min</parametername>
</parameternamelist>
<parameterdescription>
<para>Z coordinate of the deepest position of the trajectory. [m] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>origin_angle</parametername>
</parameternamelist>
<parameterdescription>
<para>Angle to the horizontal plane of the body in its reference pose. [rad] </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nn</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of increments in the trajectory.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A tuple composed of a vector aggregating the position of the body with time in meter, and a vector aggregating the orientation of the body with time following the quaternion convention. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/test/example/soil_evolution.hpp" line="46" column="2" declfile="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/test/example/soil_evolution.hpp" declline="46" declcolumn="2"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/runner/work/soil_dynamics_cpp/soil_dynamics_cpp/soil_simulator/soil_dynamics.hpp" line="12" column="1"/>
  </compounddef>
</doxygen>
